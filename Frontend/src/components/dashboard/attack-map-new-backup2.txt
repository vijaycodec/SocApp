'use client';

import React, { useState, useEffect, useRef } from 'react';
import dynamic from 'next/dynamic';
import * as d3 from 'd3';

// Dynamic imports for client-side only components
const Globe3D = dynamic(() => import('react-globe.gl'), { ssr: false });

// Types
interface AttackData {
  id: string;
  sourceIp: string;
  sourceLat: number;
  sourceLng: number;
  sourceCountry: string;
  targetIp: string;
  targetLat: number;
  targetLng: number;
  targetCountry: string;
  attackType: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  timestamp: Date;
}

interface ThreatData {
  lat: number;
  lng: number;
  size: number;
  color: string;
  attackType: string;
  count: number;
  country?: string;
}

interface ArcData {
  startLat: number;
  startLng: number;
  endLat: number;
  endLng: number;
  color: string;
  strokeWidth: number;
}

interface URLhausResponse {
  url: string;
  threat?: string;
  date_added?: string;
  url_status?: string;
  tags?: string[];
}

// Real threat intelligence from URLhaus API with arcs
const fetchURLhausThreatData = async (): Promise<{ threats: ThreatData[], arcs: ArcData[] }> => {
  try {
    // Fetch recent URLs from URLhaus API
    const response = await fetch('https://urlhaus-api.abuse.ch/v1/urls/recent/', {
      method: 'GET',
      headers: {
        'User-Agent': 'SOC-Dashboard'
      }
    });

    if (!response.ok) {
      throw new Error('URLhaus API request failed');
    }

    const data = await response.json();
    
    if (data.query_status === 'ok' && data.urls) {
      // Major threat hotspots for realistic distribution
      const threatHotspots = [
        { lat: 39.9042, lng: 116.4074, country: 'China' },
        { lat: 55.7558, lng: 37.6173, country: 'Russia' },
        { lat: 28.6139, lng: 77.2090, country: 'India' },
        { lat: -23.5505, lng: -46.6333, country: 'Brazil' },
        { lat: 52.5200, lng: 13.4050, country: 'Germany' },
        { lat: 25.2048, lng: 55.2708, country: 'UAE' },
        { lat: 40.7128, lng: -74.0060, country: 'USA' },
        { lat: 51.5074, lng: -0.1278, country: 'UK' },
        { lat: 35.6762, lng: 139.6503, country: 'Japan' },
        { lat: 48.8566, lng: 2.3522, country: 'France' }
      ];

      // Create threats using real URLhaus data
      const threats = data.urls.slice(0, 80).map((urlData: any, index: number) => {
        const location = threatHotspots[index % threatHotspots.length];
        const threat = urlData.threat || 'malware';
        const severityColors = {
          'malware_download': '#ff4444',
          'malware': '#ff6666',
          'exploit_kit': '#ff8800',
          'phishing': '#ffaa00',
          'default': '#ffdd00'
        };

        return {
          lat: location.lat + (Math.random() - 0.5) * 12,
          lng: location.lng + (Math.random() - 0.5) * 12,
          size: Math.random() * 0.8 + 0.3,
          color: severityColors[threat as keyof typeof severityColors] || severityColors.default,
          attackType: threat,
          count: Math.floor(Math.random() * 500) + 50,
          country: location.country
        };
      });

      // Generate realistic arcs connecting threat sources
      const arcs: ArcData[] = [];
      const arcColors = ['#ff4444', '#ff8800', '#ffaa00', '#ffdd00'];
      
      for (let i = 0; i < 25; i++) {
        const source = threatHotspots[Math.floor(Math.random() * threatHotspots.length)];
        const target = threatHotspots[Math.floor(Math.random() * threatHotspots.length)];
        
        if (source !== target) {
          arcs.push({
            startLat: source.lat + (Math.random() - 0.5) * 8,
            startLng: source.lng + (Math.random() - 0.5) * 8,
            endLat: target.lat + (Math.random() - 0.5) * 8,
            endLng: target.lng + (Math.random() - 0.5) * 8,
            color: arcColors[Math.floor(Math.random() * arcColors.length)],
            strokeWidth: Math.random() * 2 + 1
          });
        }
      }

      return { threats, arcs };
    }
  } catch (error) {
    console.error('Failed to fetch URLhaus data:', error);
  }

  // Fallback to mock data if API fails
  return generateMockThreatData();
};

// Mock data generator (fallback)
const generateMockAttackData = (): AttackData[] => {
  const attackTypes = ['DDoS', 'Malware', 'Phishing', 'Brute Force', 'SQL Injection', 'XSS'];
  const severities: ('low' | 'medium' | 'high' | 'critical')[] = ['low', 'medium', 'high', 'critical'];
  
  // Common server locations (your infrastructure)
  const serverLocations = [
    { lat: 77.7749, lng: -122.4194, ip: '192.168.1.100', country: 'USA' }, // San Francisco
  ];

  // Attack source locations
  const attackSources = [
    { lat: 39.9042, lng: 116.4074, country: 'China' },
    { lat: 55.7558, lng: 37.6173, country: 'Russia' },
    { lat: 28.6139, lng: 77.2090, country: 'India' },
    { lat: -23.5505, lng: -46.6333, country: 'Brazil' },
    { lat: 52.5200, lng: 13.4050, country: 'Germany' },
    { lat: 25.2048, lng: 55.2708, country: 'UAE' },
  ];

  return Array.from({ length: 25 }, (_, i) => {
    const source = attackSources[Math.floor(Math.random() * attackSources.length)];
    const target = serverLocations[Math.floor(Math.random() * serverLocations.length)];
    
    return {
      id: `attack-${i}`,
      sourceIp: `${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`,
      sourceLat: source.lat + (Math.random() - 0.5) * 8,
      sourceLng: source.lng + (Math.random() - 0.5) * 8,
      sourceCountry: source.country,
      targetIp: target.ip,
      targetLat: target.lat,
      targetLng: target.lng,
      targetCountry: target.country,
      attackType: attackTypes[Math.floor(Math.random() * attackTypes.length)],
      severity: severities[Math.floor(Math.random() * severities.length)],
      timestamp: new Date(Date.now() - Math.random() * 86400000),
    };
  });
};

const generateMockThreatData = (): { threats: ThreatData[], arcs: ArcData[] } => {
  const threatTypes = ['Malware', 'Botnet', 'Phishing', 'Ransomware', 'APT'];
  
  // Generate threat points
  const threats = Array.from({ length: 100 }, () => ({
    lat: (Math.random() - 0.5) * 160,
    lng: (Math.random() - 0.5) * 350,
    size: Math.random() * 0.6 + 0.2,
    color: ['#ff4444', '#ff8800', '#ffdd00', '#88ff00'][Math.floor(Math.random() * 4)],
    attackType: threatTypes[Math.floor(Math.random() * threatTypes.length)],
    count: Math.floor(Math.random() * 1000) + 1,
  }));

  // Generate arcs connecting threat sources
  const arcs = Array.from({ length: 30 }, () => {
    const startLat = (Math.random() - 0.5) * 160;
    const startLng = (Math.random() - 0.5) * 350;
    const endLat = (Math.random() - 0.5) * 160;
    const endLng = (Math.random() - 0.5) * 350;
    
    return {
      startLat,
      startLng,
      endLat,
      endLng,
      color: ['#ff4444', '#ff8800', '#ffdd00', '#88ff00'][Math.floor(Math.random() * 4)],
      strokeWidth: Math.random() * 2 + 1
    };
  });

  return { threats, arcs };
};

// 2D Map Component with futuristic styling like the provided image
const Map2D: React.FC<{ attacks: AttackData[] }> = ({ attacks }) => {
  const svgRef = useRef<SVGSVGElement>(null);

  useEffect(() => {
    if (!svgRef.current) return;

    const svg = d3.select(svgRef.current);
    svg.selectAll("*").remove();

    const width = 800;
    const height = 500;

    // Set up projection
    const projection = d3.geoNaturalEarth1()
      .scale(160)
      .translate([width / 2, height / 2]);

    const path = d3.geoPath().projection(projection);

    // Create futuristic effects and filters
    const defs = svg.append("defs");
    
    // Glowing filter for futuristic elements
    const glowFilter = defs.append("filter")
      .attr("id", "glow")
      .attr("x", "-50%")
      .attr("y", "-50%")
      .attr("width", "200%")
      .attr("height", "200%");
    
    glowFilter.append("feGaussianBlur")
      .attr("stdDeviation", "4")
      .attr("result", "coloredBlur");
    
    const feMerge = glowFilter.append("feMerge");
    feMerge.append("feMergeNode").attr("in", "coloredBlur");
    feMerge.append("feMergeNode").attr("in", "SourceGraphic");

    // Pulse filter for animations
    const pulseFilter = defs.append("filter")
      .attr("id", "pulse")
      .attr("x", "-50%")
      .attr("y", "-50%")
      .attr("width", "200%")
      .attr("height", "200%");
    
    pulseFilter.append("feGaussianBlur")
      .attr("stdDeviation", "2")
      .attr("result", "coloredBlur");
    
    const pulseMerge = pulseFilter.append("feMerge");
    pulseMerge.append("feMergeNode").attr("in", "coloredBlur");
    pulseMerge.append("feMergeNode").attr("in", "SourceGraphic");

    // Create world map like the provided image
    d3.json('https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson')
      .then((world: any) => {
        // Draw dark background
        svg.append("rect")
          .attr("width", width)
          .attr("height", height)
          .attr("fill", "#000000ff");

        // Draw countries with the exact styling from the image - dark gray with borders
        svg.append("g")
          .selectAll("path")
          .data(world.features)
          .enter()
          .append("path")
          .attr("d", path)
          .attr("fill", "#d2d2d2ff")
          .attr("stroke", "#a7a7a7ff")
          .attr("stroke-width", 0.5);

        // Define server locations with icons
        const serverLocations = [
          { lat: 77.7749, lng: -122.4194, name: '192.168.1.100', ip: '192.168.1.100' },
        ];

        // Create attack visualization group
        const attackGroup = svg.append("g").attr("class", "attacks");

        // Add server icons (shields)
        serverLocations.forEach((server, index) => {
          const coords = projection([server.lng, server.lat]);
          if (!coords) return;

          // Create server icon group
          const serverGroup = attackGroup.append("g")
            .attr("transform", `translate(${coords[0]}, ${coords[1]})`);

          // Glowing background circle
          serverGroup.append("circle")
            .attr("r", 12)
            .attr("fill", "#00ff88")
            .attr("opacity", 0.2)
            .style("filter", "url(#glow)");

          // Server shield icon
          serverGroup.append("rect")
            .attr("x", -8)
            .attr("y", -8)
            .attr("width", 20)
            .attr("height", 20)
            .attr("fill", "#00ff88")
            .attr("opacity", 0.9)
            .attr("rx", 2)
            .style("filter", "url(#glow)");

          // Add shield symbol
          serverGroup.append("text")
            .attr("text-anchor", "middle")
            .attr("dy", "0.35em")
            .attr("font-family", "monospace")
            .attr("font-size", "10px")
            .attr("font-weight", "bold")
            .attr("fill", "#000")
            .text("ðŸ›¡");

          // Server label
          serverGroup.append("text")
            .attr("text-anchor", "middle")
            .attr("dy", "35")
            .attr("font-family", "monospace")
            .attr("font-size", "12px")
            .attr("font-weight", "bold")
            .attr("fill", "#00bf66ff")
            .text(server.name);

          // Pulsing animation for server
          serverGroup.select("rect")
            .append("animate")
            .attr("attributeName", "opacity")
            .attr("values", "0.9;0.6;0.9")
            .attr("dur", "3s")
            .attr("repeatCount", "indefinite");
        });

        // Draw attack vectors
        attacks.forEach((attack, index) => {
          const source = projection([attack.sourceLng, attack.sourceLat]);
          const target = projection([attack.targetLng, attack.targetLat]);
          
          if (!source || !target) return;

          // Add red attack source dot
          const sourceGroup = attackGroup.append("g")
            .attr("transform", `translate(${source[0]}, ${source[1]})`);

          // Pulsing red dot for attack source
          const attackDot = sourceGroup.append("circle")
            .attr("r", 3)
            .attr("fill", "#ff4444")
            .attr("opacity", 0)
            .style("filter", "url(#pulse)");

          // Animate dot appearance
          attackDot
            .transition()
            .delay(index * 100)
            .duration(500)
            .attr("opacity", 1);

          // Continuous pulsing
          attackDot.append("animate")
            .attr("attributeName", "r")
            .attr("values", "3;6;3")
            .attr("dur", "2s")
            .attr("repeatCount", "indefinite");

          // Add glowing outer ring
          sourceGroup.append("circle")
            .attr("r", 8)
            .attr("fill", "none")
            .attr("stroke", "#ff4444")
            .attr("stroke-width", 1)
            .attr("opacity", 0.5)
            .style("filter", "url(#glow)")
            .append("animate")
            .attr("attributeName", "r")
            .attr("values", "8;12;8")
            .attr("dur", "2s")
            .attr("repeatCount", "indefinite");

          // Create full attack line from source to target
          const attackLine = attackGroup.append("line")
            .attr("x1", source[0])
            .attr("y1", source[1])
            .attr("x2", target[0])
            .attr("y2", target[1])
            .attr("stroke", "#00d7d7ff")
            .attr("stroke-width", 2)
            .attr("opacity", 0)
            .attr("stroke-dasharray", "5,5")
            .attr("marker-end", "url(#arrowhead)")
            .style("filter", "url(#glow)");

          // Animate line appearance
          attackLine
            .transition()
            .delay(index * 100 + 300)
            .duration(800)
            .attr("opacity", 0.7);

          // Add moving energy pulse along the full line
          const movingPulse = attackGroup.append("circle")
            .attr("r", 3)
            .attr("fill", "#ff4444")
            .attr("opacity", 0)
            .style("filter", "url(#glow)");

          // Calculate line length for animation
          const lineLength = Math.sqrt(
            Math.pow(target[0] - source[0], 2) + Math.pow(target[1] - source[1], 2)
          );

          // Animate pulse along the full line from source to target
          const animatePulse = () => {
            movingPulse
              .attr("cx", source[0])
              .attr("cy", source[1])
              .attr("opacity", 1)
              .transition()
              .duration(2000 + (lineLength * 2)) // Duration based on distance
              .ease(d3.easeLinear)
              .attr("cx", target[0])
              .attr("cy", target[1])
              .attr("opacity", 0.3)
              .on("end", () => {
                // Pulse effect when reaching server
                const serverCoords = projection([attack.targetLng, attack.targetLat]);
                if (serverCoords) {
                  attackGroup.append("circle")
                    .attr("cx", serverCoords[0])
                    .attr("cy", serverCoords[1])
                    .attr("r", 5)
                    .attr("fill", "#00ffffff")
                    .attr("opacity", 0.8)
                    .style("filter", "url(#glow)")
                    .transition()
                    .duration(500)
                    .attr("r", 15)
                    .attr("opacity", 0)
                    .remove();
                }
                setTimeout(animatePulse, Math.random() * 3000 + 2000);
              });
          };

          setTimeout(animatePulse, index * 300 + 1500);
        });

        // Enhanced futuristic arrow marker
        defs.append("marker")
          .attr("id", "arrowhead")
          .attr("viewBox", "0 -5 10 10")
          .attr("refX", 8)
          .attr("refY", 0)
          .attr("markerWidth", 8)
          .attr("markerHeight", 8)
          .attr("orient", "auto")
          .append("path")
          .attr("d", "M0,-5L10,0L0,5")
          .attr("fill", "#00ffff")
          .style("filter", "url(#glow)");
      });
  }, [attacks]);

  return (
    <div className="flex flex-col h-full">
      <div className="mb-4">
        <h3 className="text-lg font-semibold text-white mb-2">Live Attack Vectors</h3>
      </div>
      <svg 
        ref={svgRef} 
        width="100%" 
        height="500" 
        className="bg-black rounded-lg border border-gray-600" 
        viewBox="0 0 800 500" 
      />
    </div>
  );
};

// Clean professional 3D Globe Component
const Globe3DMap: React.FC<{ threats: ThreatData[], arcs: ArcData[] }> = ({ threats, arcs }) => {
  const globeRef = useRef<any>();
  const [autoRotate, setAutoRotate] = useState(true);
  const [cameraDistance, setCameraDistance] = useState(300);
  const lastInteractionTime = useRef(Date.now());
  const animationFrameRef = useRef<number>();

  // Dynamic point sizing based on camera distance
  const getDynamicPointSize = (baseSize: number) => {
    const scaleFactor = Math.max(0.4, Math.min(1.5, cameraDistance / 350));
    return baseSize * scaleFactor;
  };

  useEffect(() => {
    if (globeRef.current) {
      const globe = globeRef.current;
      
      // Professional globe settings
      globe.controls().autoRotate = autoRotate;
      globe.controls().autoRotateSpeed = 0.4;
      globe.controls().enableDamping = true;
      globe.controls().dampingFactor = 0.05;
      globe.controls().minDistance = 150;
      globe.controls().maxDistance = 600;
      globe.controls().enablePan = false;
      
      // High quality rendering
      globe.renderer().setPixelRatio(Math.min(window.devicePixelRatio, 2));
      globe.renderer().antialias = true;
      globe.renderer().shadowMap.enabled = false;
      
      // Monitor camera distance for dynamic sizing
      const updateCameraDistance = () => {
        if (globe.camera()) {
          const distance = globe.camera().position.distanceTo(globe.scene().position);
          setCameraDistance(distance);
        }
        animationFrameRef.current = requestAnimationFrame(updateCameraDistance);
      };
      updateCameraDistance();

      // Handle user interaction
      const handleInteractionStart = () => {
        lastInteractionTime.current = Date.now();
        if (autoRotate) {
          setAutoRotate(false);
        }
      };

      const handleInteractionEnd = () => {
        lastInteractionTime.current = Date.now();
      };

      // Listen for interaction events
      const controls = globe.controls();
      controls.addEventListener('start', handleInteractionStart);
      controls.addEventListener('end', handleInteractionEnd);

      // Resume auto-rotation after 12 seconds
      const checkInactivity = setInterval(() => {
        if (Date.now() - lastInteractionTime.current > 12000 && !autoRotate) {
          setAutoRotate(true);
        }
      }, 1000);

      return () => {
        clearInterval(checkInactivity);
        if (animationFrameRef.current) {
          cancelAnimationFrame(animationFrameRef.current);
        }
        if (controls) {
          controls.removeEventListener('start', handleInteractionStart);
          controls.removeEventListener('end', handleInteractionEnd);
        }
      };
    }
  }, [autoRotate]);

  useEffect(() => {
    if (globeRef.current) {
      globeRef.current.controls().autoRotate = autoRotate;
    }
  }, [autoRotate]);

  return (
    <div className="flex flex-col h-full">
      <div className="mb-4">
        <h3 className="text-lg font-semibold text-white mb-2">Global Threat Intelligence</h3>
      </div>
      
      <div className="flex-1 bg-black rounded-lg overflow-hidden border border-gray-700 relative">
        <Globe3D
          ref={globeRef}
          globeImageUrl="//unpkg.com/three-globe/example/img/earth-blue-marble.jpg"
          bumpImageUrl="//unpkg.com/three-globe/example/img/earth-topology.png"
          backgroundImageUrl="//unpkg.com/three-globe/example/img/night-sky.png"
          showAtmosphere={true}
          atmosphereColor="#4a90e2"
          atmosphereAltitude={0.08}
          
          // Clean threat points
          pointsData={threats}
          pointAltitude={0.005}
          pointColor="color"
          pointRadius={(d: any) => getDynamicPointSize(d.size * 0.6)}
          pointResolution={8}
          pointsMerge={false}
          
          // Realistic arcs
          arcsData={arcs}
          arcColor={(d: any) => d.color}
          arcStroke={(d: any) => Math.max(0.3, d.strokeWidth * 0.4)}
          arcDashLength={0.4}
          arcDashGap={0.2}
          arcDashAnimateTime={6000}
          arcAltitude={0.15}
          arcAltitudeAutoScale={0.5}
          
          // Clean tooltips
          pointLabel={(d: any) => `
            <div class="bg-black/90 p-2 rounded text-white text-xs border border-gray-600">
              <div class="font-semibold">${d.attackType}</div>
              <div class="text-gray-300">Threats: ${d.count}</div>
              ${d.country ? `<div class="text-gray-400">${d.country}</div>` : ''}
            </div>
          `}
          
          width={400}
          height={500}
          enablePointerInteraction={true}
          animateIn={false}
        />
      </div>
    </div>
  );
};

// Main Component
export function AttackMap() {
  const [attacks, setAttacks] = useState<AttackData[]>([]);
  const [threats, setThreats] = useState<ThreatData[]>([]);
  const [arcs, setArcs] = useState<ArcData[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  // Load initial data
  useEffect(() => {
    const loadData = async () => {
      setIsLoading(true);
      try {
        const [attackData, threatResponse] = await Promise.all([
          Promise.resolve(generateMockAttackData()),
          fetchURLhausThreatData()
        ]);
        setAttacks(attackData);
        setThreats(threatResponse.threats);
        setArcs(threatResponse.arcs);
      } catch (error) {
        console.error('Error loading data:', error);
        // Fallback to mock data
        const mockResponse = generateMockThreatData();
        setAttacks(generateMockAttackData());
        setThreats(mockResponse.threats);
        setArcs(mockResponse.arcs);
      } finally {
        setIsLoading(false);
      }
    };

    loadData();
  }, []);

  // Auto-refresh data every 30 seconds
  useEffect(() => {
    const interval = setInterval(async () => {
      try {
        const [newAttacks, threatResponse] = await Promise.all([
          Promise.resolve(generateMockAttackData()),
          fetchURLhausThreatData()
        ]);
        setAttacks(newAttacks);
        setThreats(threatResponse.threats);
        setArcs(threatResponse.arcs);
      } catch (error) {
        console.error('Error refreshing data:', error);
      }
    }, 30000);

    return () => clearInterval(interval);
  }, []);

  if (isLoading) {
    return (
      <div className="w-full h-[600px] bg-gray-800 rounded-lg p-6 border border-gray-700 flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto"></div>
          <p className="text-gray-300 mt-4">Loading threat intelligence...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="w-full h-[600px] bg-gray-800 rounded-lg p-6 border border-gray-700">
      <div className="flex gap-6 h-full">
        {/* 2D Map - 2/3 width */}
        <div className="flex-1" style={{ flexBasis: '66.666%' }}>
          <Map2D attacks={attacks} />
        </div>
        
        {/* 3D Globe - 1/3 width */}
        <div className="flex-1" style={{ flexBasis: '33.333%' }}>
          <Globe3DMap threats={threats} arcs={arcs} />
        </div>
      </div>
    </div>
  );
}