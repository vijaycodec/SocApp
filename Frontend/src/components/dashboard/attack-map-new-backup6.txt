src\components\dashboard\attack-map.tsx:

'use client';

import React, { useState, useEffect, useRef } from 'react';
import dynamic from 'next/dynamic';
import * as d3 from 'd3';
import { useThreatData } from '../../contexts/ThreatDataContext';

// Types (keeping local for component use)
interface AttackData {
  id: string;
  sourceIp: string;
  sourceLat: number;
  sourceLng: number;
  sourceCountry: string;
  targetIp: string;
  targetLat: number;
  targetLng: number;
  targetCountry: string;
  attackType: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  timestamp: Date;
}

interface ThreatData {
  lat: number;
  lng: number;
  size: number;
  color: string;
  attackType: string;
  count: number;
  country?: string;
}

interface ArcData {
  startLat: number;
  startLng: number;
  endLat: number;
  endLng: number;
  color: string;
  strokeWidth: number;
}

// Dynamic imports for client-side only components
const Globe3D = dynamic(() => import('react-globe.gl'), { ssr: false });

// Types
interface AttackData {
  id: string;
  sourceIp: string;
  sourceLat: number;
  sourceLng: number;
  sourceCountry: string;
  targetIp: string;
  targetLat: number;
  targetLng: number;
  targetCountry: string;
  attackType: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  timestamp: Date;
}

interface ThreatData {
  lat: number;
  lng: number;
  size: number;
  color: string;
  attackType: string;
  count: number;
  country?: string;
}

interface ArcData {
  startLat: number;
  startLng: number;
  endLat: number;
  endLng: number;
  color: string;
  strokeWidth: number;
}

// IP Geolocation function (using ipapi.co for demo - replace with your preferred service)
const getIpLocation = async (ip: string): Promise<{lat: number, lng: number, country: string} | null> => {
  try {
    // Using a free IP geolocation service - replace with your preferred provider
    const response = await fetch(`https://ipapi.co/${ip}/json/`);
    if (response.ok) {
      const data = await response.json();
      return {
        lat: parseFloat(data.latitude) || 0,
        lng: parseFloat(data.longitude) || 0,
        country: data.country_name || 'Unknown'
      };
    }
  } catch (error) {
    console.error('IP geolocation failed:', error);
  }
  return null;
};

// Fixed OTX integration using server-side proxy
const fetchOTXThreatData = async (): Promise<{ threats: ThreatData[], arcs: ArcData[] }> => {
  try {
    // Call your server-side API endpoint instead of OTX directly
    const response = await fetch('/api/otx-proxy', {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    });

    if (response.ok) {
      const data = await response.json();
      
      if (data.success && data.threats && data.arcs) {
        return {
          threats: data.threats,
          arcs: data.arcs
        };
      } else {
        console.warn('OTX API returned no data, using mock data');
        return generateMockOTXData();
      }
    } else {
      console.error('OTX proxy API request failed:', response.status);
      return generateMockOTXData();
    }
  } catch (error) {
    console.error('Failed to fetch OTX data via proxy:', error);
    return generateMockOTXData();
  }
};

// Mock OTX data for fallback
const generateMockOTXData = (): { threats: ThreatData[], arcs: ArcData[] } => {
  const otxThreatTypes = ['APT Campaign', 'Malware Family', 'Phishing Campaign', 'Botnet C2', 'Exploit Kit'];
  const otxColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8'];
  
  // Generate OTX-style threat points with realistic locations
  const realThreatLocations = [
    { lat: 39.9042, lng: 116.4074, country: 'China' },
    { lat: 55.7558, lng: 37.6173, country: 'Russia' },
    { lat: 28.6139, lng: 77.2090, country: 'India' },
    { lat: 40.7128, lng: -74.0060, country: 'USA' },
    { lat: 52.5200, lng: 13.4050, country: 'Germany' },
    { lat: 51.5074, lng: -0.1278, country: 'UK' },
    { lat: 35.6762, lng: 139.6503, country: 'Japan' },
    { lat: -23.5505, lng: -46.6333, country: 'Brazil' }
  ];

  const threats = Array.from({ length: 50 }, (_, i) => {
    const location = realThreatLocations[i % realThreatLocations.length];
    return {
      lat: location.lat + (Math.random() - 0.5) * 8,
      lng: location.lng + (Math.random() - 0.5) * 8,
      size: Math.random() * 0.8 + 0.4,
      color: otxColors[Math.floor(Math.random() * otxColors.length)],
      attackType: otxThreatTypes[Math.floor(Math.random() * otxThreatTypes.length)],
      count: Math.floor(Math.random() * 1000) + 100,
      country: location.country
    };
  });

  // Generate arcs
  const arcs = Array.from({ length: 25 }, () => {
    const source = realThreatLocations[Math.floor(Math.random() * realThreatLocations.length)];
    const target = realThreatLocations[Math.floor(Math.random() * realThreatLocations.length)];
    
    return {
      startLat: source.lat + (Math.random() - 0.5) * 5,
      startLng: source.lng + (Math.random() - 0.5) * 5,
      endLat: target.lat + (Math.random() - 0.5) * 5,
      endLng: target.lng + (Math.random() - 0.5) * 5,
      color: otxColors[Math.floor(Math.random() * otxColors.length)],
      strokeWidth: Math.random() * 2 + 1
    };
  });

  return { threats, arcs };
};

// Custom dummy data for 2D map (your infrastructure attacks)
const generateCustomAttackData = (): AttackData[] => {
  const attackTypes = ['DDoS', 'Malware', 'Phishing', 'Brute Force', 'SQL Injection', 'XSS', 'Ransomware', 'Port Scan'];
  const severities: ('low' | 'medium' | 'high' | 'critical')[] = ['low', 'medium', 'high', 'critical'];
  
  // Your infrastructure servers (expanded with more locations)
  const serverLocations = [
    { lat: 37.7749, lng: -122.4194, ip: '192.168.1.100', country: 'USA' }, // San Francisco
    { lat: 40.7128, lng: -74.0060, ip: '192.168.1.101', country: 'USA' },  // New York
    { lat: 51.5074, lng: -0.1278, ip: '192.168.1.102', country: 'UK' },    // London
    { lat: 35.6762, lng: 139.6503, ip: '192.168.1.103', country: 'Japan' }, // Tokyo
    { lat: 1.3521, lng: 103.8198, ip: '192.168.1.104', country: 'Singapore' }, // Singapore
  ];

  // Realistic attack sources with threat intelligence weights
  const attackSources = [
    { lat: 39.9042, lng: 116.4074, country: 'China', threatLevel: 'high' },
    { lat: 55.7558, lng: 37.6173, country: 'Russia', threatLevel: 'critical' },
    { lat: 28.6139, lng: 77.2090, country: 'India', threatLevel: 'medium' },
    { lat: -23.5505, lng: -46.6333, country: 'Brazil', threatLevel: 'medium' },
    { lat: 52.5200, lng: 13.4050, country: 'Germany', threatLevel: 'low' },
    { lat: 25.2048, lng: 55.2708, country: 'UAE', threatLevel: 'low' },
    { lat: 40.7589, lng: -73.9851, country: 'USA', threatLevel: 'medium' }, // Internal threats
    { lat: 51.5074, lng: -0.1278, country: 'UK', threatLevel: 'low' },
  ];

  // Generate realistic custom attacks (increased from 30 to 100)
  return Array.from({ length: 100 }, (_, i) => {
    const source = attackSources[Math.floor(Math.random() * attackSources.length)];
    const target = serverLocations[Math.floor(Math.random() * serverLocations.length)];
    
    // Severity based on threat level
    let severity: 'low' | 'medium' | 'high' | 'critical';
    switch (source.threatLevel) {
      case 'critical':
        severity = Math.random() > 0.3 ? 'critical' : 'high';
        break;
      case 'high':
        severity = Math.random() > 0.4 ? 'high' : 'medium';
        break;
      case 'medium':
        severity = Math.random() > 0.5 ? 'medium' : 'low';
        break;
      default:
        severity = Math.random() > 0.7 ? 'medium' : 'low';
    }

    return {
      id: `custom-attack-${i}`,
      sourceIp: `${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`,
      sourceLat: source.lat + (Math.random() - 0.5) * 6,
      sourceLng: source.lng + (Math.random() - 0.5) * 6,
      sourceCountry: source.country,
      targetIp: target.ip,
      targetLat: target.lat,
      targetLng: target.lng,
      targetCountry: target.country,
      attackType: attackTypes[Math.floor(Math.random() * attackTypes.length)],
      severity: severity,
      timestamp: new Date(Date.now() - Math.random() * 86400000),
    };
  });
};

// 2D Map Component with futuristic styling like the provided image
const Map2D: React.FC<{ attacks: AttackData[], isRefreshing?: boolean }> = ({ attacks, isRefreshing = false }) => {
  const svgRef = useRef<SVGSVGElement>(null);

  useEffect(() => {
    if (!svgRef.current) return;

    const svg = d3.select(svgRef.current);
    svg.selectAll("*").remove();

    const width = 800;
    const height = 500;

    // Set up projection
    const projection = d3.geoNaturalEarth1()
      .scale(160)
      .translate([width / 2, height / 2]);

    const path = d3.geoPath().projection(projection);

    // Create futuristic effects and filters
    const defs = svg.append("defs");
    
    // Glowing filter for futuristic elements
    const glowFilter = defs.append("filter")
      .attr("id", "glow")
      .attr("x", "-50%")
      .attr("y", "-50%")
      .attr("width", "200%")
      .attr("height", "200%");
    
    glowFilter.append("feGaussianBlur")
      .attr("stdDeviation", "4")
      .attr("result", "coloredBlur");
    
    const feMerge = glowFilter.append("feMerge");
    feMerge.append("feMergeNode").attr("in", "coloredBlur");
    feMerge.append("feMergeNode").attr("in", "SourceGraphic");

    // Pulse filter for animations
    const pulseFilter = defs.append("filter")
      .attr("id", "pulse")
      .attr("x", "-50%")
      .attr("y", "-50%")
      .attr("width", "200%")
      .attr("height", "200%");
    
    pulseFilter.append("feGaussianBlur")
      .attr("stdDeviation", "2")
      .attr("result", "coloredBlur");
    
    const pulseMerge = pulseFilter.append("feMerge");
    pulseMerge.append("feMergeNode").attr("in", "coloredBlur");
    pulseMerge.append("feMergeNode").attr("in", "SourceGraphic");

    // Create world map like the provided image
    d3.json('https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson')
      .then((world: any) => {
        // Draw dark background
        svg.append("rect")
          .attr("width", width)
          .attr("height", height)
          .attr("fill", "#000000ff");

        // Draw countries with the exact styling from the image - dark gray with borders
        svg.append("g")
          .selectAll("path")
          .data(world.features)
          .enter()
          .append("path")
          .attr("d", path)
          .attr("fill", "#d2d2d2ff")
          .attr("stroke", "#a7a7a7ff")
          .attr("stroke-width", 0.5);

        // Define server locations with icons (expanded)
        const serverLocations = [
          { lat: 37.7749, lng: -122.4194, name: 'SF-Server', ip: '192.168.1.100' },
          { lat: 40.7128, lng: -74.0060, name: 'NY-Server', ip: '192.168.1.101' },
          { lat: 51.5074, lng: -0.1278, name: 'UK-Server', ip: '192.168.1.102' },
          { lat: 35.6762, lng: 139.6503, name: 'JP-Server', ip: '192.168.1.103' },
          { lat: 1.3521, lng: 103.8198, name: 'SG-Server', ip: '192.168.1.104' },
        ];

        // Create attack visualization group
        const attackGroup = svg.append("g").attr("class", "attacks");

        // Add server icons (shields)
        serverLocations.forEach((server, index) => {
          const coords = projection([server.lng, server.lat]);
          if (!coords) return;

          // Create server icon group
          const serverGroup = attackGroup.append("g")
            .attr("transform", `translate(${coords[0]}, ${coords[1]})`);

          // Glowing background circle
          serverGroup.append("circle")
            .attr("r", 12)
            .attr("fill", "#00ff88")
            .attr("opacity", 0.2)
            .style("filter", "url(#glow)");

          // Server shield icon
          serverGroup.append("rect")
            .attr("x", -8)
            .attr("y", -8)
            .attr("width", 20)
            .attr("height", 20)
            .attr("fill", "#00ff88")
            .attr("opacity", 0.9)
            .attr("rx", 2)
            .style("filter", "url(#glow)");

          // Add shield symbol
          serverGroup.append("text")
            .attr("text-anchor", "middle")
            .attr("dy", "0.35em")
            .attr("font-family", "monospace")
            .attr("font-size", "10px")
            .attr("font-weight", "bold")
            .attr("fill", "#000")
            .text("üõ°");

          // Server label
          serverGroup.append("text")
            .attr("text-anchor", "middle")
            .attr("dy", "35")
            .attr("font-family", "monospace")
            .attr("font-size", "12px")
            .attr("font-weight", "bold")
            .attr("fill", "#00bf66ff")
            .text(server.name);

          // Pulsing animation for server
          serverGroup.select("rect")
            .append("animate")
            .attr("attributeName", "opacity")
            .attr("values", "0.9;0.6;0.9")
            .attr("dur", "3s")
            .attr("repeatCount", "indefinite");
        });

        // Draw attack vectors
        attacks.forEach((attack, index) => {
          const source = projection([attack.sourceLng, attack.sourceLat]);
          const target = projection([attack.targetLng, attack.targetLat]);
          
          if (!source || !target) return;

          // Add red attack source dot
          const sourceGroup = attackGroup.append("g")
            .attr("transform", `translate(${source[0]}, ${source[1]})`);

          // Pulsing red dot for attack source
          const attackDot = sourceGroup.append("circle")
            .attr("r", 3)
            .attr("fill", "#ff4444")
            .attr("opacity", 0)
            .style("filter", "url(#pulse)");

          // Animate dot appearance
          attackDot
            .transition()
            .delay(index * 100)
            .duration(500)
            .attr("opacity", 1);

          // Continuous pulsing
          attackDot.append("animate")
            .attr("attributeName", "r")
            .attr("values", "3;6;3")
            .attr("dur", "2s")
            .attr("repeatCount", "indefinite");

          // Add glowing outer ring
          sourceGroup.append("circle")
            .attr("r", 8)
            .attr("fill", "none")
            .attr("stroke", "#ff4444")
            .attr("stroke-width", 1)
            .attr("opacity", 0.5)
            .style("filter", "url(#glow)")
            .append("animate")
            .attr("attributeName", "r")
            .attr("values", "8;12;8")
            .attr("dur", "2s")
            .attr("repeatCount", "indefinite");

          // Create full attack line from source to target
          const attackLine = attackGroup.append("line")
            .attr("x1", source[0])
            .attr("y1", source[1])
            .attr("x2", target[0])
            .attr("y2", target[1])
            .attr("stroke", "#00d7d7ff")
            .attr("stroke-width", 2)
            .attr("opacity", 0)
            .attr("stroke-dasharray", "5,5")
            .attr("marker-end", "url(#arrowhead)")
            .style("filter", "url(#glow)");

          // Animate line appearance
          attackLine
            .transition()
            .delay(index * 100 + 300)
            .duration(800)
            .attr("opacity", 0.7);

          // Add moving energy pulse along the full line
          const movingPulse = attackGroup.append("circle")
            .attr("r", 3)
            .attr("fill", "#ff4444")
            .attr("opacity", 0)
            .style("filter", "url(#glow)");

          // Calculate line length for animation
          const lineLength = Math.sqrt(
            Math.pow(target[0] - source[0], 2) + Math.pow(target[1] - source[1], 2)
          );

          // Animate pulse along the full line from source to target
          const animatePulse = () => {
            movingPulse
              .attr("cx", source[0])
              .attr("cy", source[1])
              .attr("opacity", 1)
              .transition()
              .duration(2000 + (lineLength * 2)) // Duration based on distance
              .ease(d3.easeLinear)
              .attr("cx", target[0])
              .attr("cy", target[1])
              .attr("opacity", 0.3)
              .on("end", () => {
                // Pulse effect when reaching server
                const serverCoords = projection([attack.targetLng, attack.targetLat]);
                if (serverCoords) {
                  attackGroup.append("circle")
                    .attr("cx", serverCoords[0])
                    .attr("cy", serverCoords[1])
                    .attr("r", 5)
                    .attr("fill", "#00ffffff")
                    .attr("opacity", 0.8)
                    .style("filter", "url(#glow)")
                    .transition()
                    .duration(500)
                    .attr("r", 15)
                    .attr("opacity", 0)
                    .remove();
                }
                setTimeout(animatePulse, Math.random() * 3000 + 2000);
              });
          };

          setTimeout(animatePulse, index * 300 + 1500);
        });

        // Enhanced futuristic arrow marker
        defs.append("marker")
          .attr("id", "arrowhead")
          .attr("viewBox", "0 -5 10 10")
          .attr("refX", 8)
          .attr("refY", 0)
          .attr("markerWidth", 8)
          .attr("markerHeight", 8)
          .attr("orient", "auto")
          .append("path")
          .attr("d", "M0,-5L10,0L0,5")
          .attr("fill", "#00ffff")
          .style("filter", "url(#glow)");
      });
  }, [attacks]);

  return (
    <div className="flex flex-col h-full">
      <div className="mb-4 flex justify-between items-center">
        <h3 className="text-lg font-semibold text-white mb-2">Live Attack Vectors</h3>
        {isRefreshing && (
          <div className="flex items-center gap-2 text-xs text-yellow-400">
            <div className="w-3 h-3 border border-yellow-400 border-t-transparent rounded-full animate-spin"></div>
            <span>Updating...</span>
          </div>
        )}
      </div>
      <div className={`transition-opacity duration-300 ${isRefreshing ? 'opacity-75' : 'opacity-100'}`}>
        <svg 
          ref={svgRef} 
          width="100%" 
          height="500" 
          className="bg-black rounded-lg border border-gray-600" 
          viewBox="0 0 800 500" 
        />
      </div>
    </div>
  );
};

// Clean professional 3D Globe Component
const Globe3DMap: React.FC<{ threats: ThreatData[], arcs: ArcData[], isRefreshing?: boolean }> = ({ threats, arcs, isRefreshing = false }) => {
  const globeRef = useRef<any>();
  const [autoRotate, setAutoRotate] = useState(true);
  const [cameraDistance, setCameraDistance] = useState(300);
  const lastInteractionTime = useRef(Date.now());
  const animationFrameRef = useRef<number>();

  // Dynamic point sizing based on camera distance
  const getDynamicPointSize = (baseSize: number) => {
    const scaleFactor = Math.max(0.4, Math.min(1.5, cameraDistance / 350));
    return baseSize * scaleFactor;
  };

  useEffect(() => {
    if (globeRef.current) {
      const globe = globeRef.current;
      
      // Professional globe settings
      globe.controls().autoRotate = autoRotate;
      globe.controls().autoRotateSpeed = 0.4;
      globe.controls().enableDamping = true;
      globe.controls().dampingFactor = 0.05;
      globe.controls().minDistance = 150;
      globe.controls().maxDistance = 600;
      globe.controls().enablePan = false;
      
      // High quality rendering
      globe.renderer().setPixelRatio(Math.min(window.devicePixelRatio, 2));
      globe.renderer().antialias = true;
      globe.renderer().shadowMap.enabled = false;
      
      // Monitor camera distance for dynamic sizing
      const updateCameraDistance = () => {
        if (globe.camera()) {
          const distance = globe.camera().position.distanceTo(globe.scene().position);
          setCameraDistance(distance);
        }
        animationFrameRef.current = requestAnimationFrame(updateCameraDistance);
      };
      updateCameraDistance();

      // Handle user interaction
      const handleInteractionStart = () => {
        lastInteractionTime.current = Date.now();
        if (autoRotate) {
          setAutoRotate(false);
        }
      };

      const handleInteractionEnd = () => {
        lastInteractionTime.current = Date.now();
      };

      // Listen for interaction events
      const controls = globe.controls();
      controls.addEventListener('start', handleInteractionStart);
      controls.addEventListener('end', handleInteractionEnd);

      // Resume auto-rotation after 12 seconds
      const checkInactivity = setInterval(() => {
        if (Date.now() - lastInteractionTime.current > 12000 && !autoRotate) {
          setAutoRotate(true);
        }
      }, 1000);

      return () => {
        clearInterval(checkInactivity);
        if (animationFrameRef.current) {
          cancelAnimationFrame(animationFrameRef.current);
        }
        if (controls) {
          controls.removeEventListener('start', handleInteractionStart);
          controls.removeEventListener('end', handleInteractionEnd);
        }
      };
    }
  }, [autoRotate]);

  useEffect(() => {
    if (globeRef.current) {
      globeRef.current.controls().autoRotate = autoRotate;
    }
  }, [autoRotate]);

  return (
    <div className="flex flex-col h-full">
      <div className="mb-4 flex justify-between items-center">
        <h3 className="text-lg font-semibold text-white mb-2">Global Threat Intelligence</h3>
        {isRefreshing && (
          <div className="flex items-center gap-2 text-xs text-yellow-400">
            <div className="w-3 h-3 border border-yellow-400 border-t-transparent rounded-full animate-spin"></div>
            <span>Updating...</span>
          </div>
        )}
      </div>
      
      <div className={`flex-1 bg-black rounded-lg overflow-hidden border border-gray-700 relative transition-opacity duration-300 ${isRefreshing ? 'opacity-75' : 'opacity-100'}`}>
        <Globe3D
          ref={globeRef}
          globeImageUrl="//unpkg.com/three-globe/example/img/earth-blue-marble.jpg"
          bumpImageUrl="//unpkg.com/three-globe/example/img/earth-topology.png"
          backgroundImageUrl="//unpkg.com/three-globe/example/img/night-sky.png"
          showAtmosphere={true}
          atmosphereColor="#4a90e2"
          atmosphereAltitude={0.08}
          
          // Clean threat points
          pointsData={threats}
          pointAltitude={0.005}
          pointColor="color"
          pointRadius={(d: any) => getDynamicPointSize(d.size * 0.6)}
          pointResolution={8}
          pointsMerge={false}
          
          // Realistic arcs
          arcsData={arcs}
          arcColor={(d: any) => d.color}
          arcStroke={(d: any) => Math.max(0.3, d.strokeWidth * 0.4)}
          arcDashLength={0.4}
          arcDashGap={0.2}
          arcDashAnimateTime={6000}
          arcAltitude={0.15}
          arcAltitudeAutoScale={0.5}
          
          // Clean tooltips
          pointLabel={(d: any) => `
            <div class="bg-black/90 p-2 rounded text-white text-xs border border-gray-600">
              <div class="font-semibold">${d.attackType}</div>
              <div class="text-gray-300">Threats: ${d.count}</div>
              ${d.country ? `<div class="text-gray-400">${d.country}</div>` : ''}
            </div>
          `}
          
          width={400}
          height={500}
          enablePointerInteraction={true}
          animateIn={false}
        />
      </div>
    </div>
  );
};

// Main Component - Now optimized to use context
export function AttackMap() {
  const { attacks, threats, arcs, isLoading, lastUpdated, refreshData, isRefreshing } = useThreatData();

  // Only show loading screen on initial load when there's no data
  if (isLoading && attacks.length === 0 && threats.length === 0) {
    return (
      <div className="w-full h-[600px] bg-gray-800 rounded-lg p-6 border border-gray-700 flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto"></div>
          <p className="text-gray-300 mt-4">Loading threat intelligence...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="w-full h-[600px] bg-gray-800 rounded-lg p-6 border border-gray-700 relative">
      {/* Background refresh indicator */}
      {isRefreshing && (
        <div className="absolute top-4 right-4 z-10 bg-blue-600/20 backdrop-blur-sm border border-blue-500/30 rounded-lg px-3 py-2 flex items-center gap-2">
          <div className="w-4 h-4 border-2 border-blue-400 border-t-transparent rounded-full animate-spin"></div>
          <span className="text-blue-300 text-sm">Updating data...</span>
        </div>
      )}
      
      {/* Header with refresh info */}
      {/* <div className="flex justify-between items-center mb-4">
        <div className="flex items-center gap-4">
          <h2 className="text-xl font-semibold text-white">Live Threat Intelligence</h2>
          <div className="flex items-center gap-2 text-sm text-gray-400">
            <div className={`w-2 h-2 rounded-full ${isRefreshing ? 'bg-yellow-500 animate-pulse' : 'bg-green-500 animate-pulse'}`}></div>
            <span>{isRefreshing ? 'Updating...' : 'Live Feed'}</span>
          </div>
        </div>
        
        <div className="flex items-center gap-4">
          {lastUpdated && (
            <span className="text-sm text-gray-400">
              Last updated: {lastUpdated.toLocaleTimeString()}
            </span>
          )}
          <button
            onClick={refreshData}
            disabled={isRefreshing}
            className="px-3 py-1 bg-blue-600 hover:bg-blue-700 disabled:bg-blue-800 disabled:cursor-not-allowed text-white text-sm rounded transition-colors flex items-center gap-2"
          >
            <svg 
              className={`w-4 h-4 ${isRefreshing ? 'animate-spin' : ''}`} 
              fill="none" 
              viewBox="0 0 24 24" 
              stroke="currentColor"
            >
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
            </svg>
            {isRefreshing ? 'Refreshing...' : 'Refresh'}
          </button>
        </div>
      </div> */}

      {/* Stats Bar with loading indicators */}
      {/* <div className="flex gap-4 mb-4 text-sm">
        <div className={`bg-gray-700 px-3 py-1 rounded transition-all duration-300 ${isRefreshing ? 'bg-gray-600 animate-pulse' : ''}`}>
          <span className="text-gray-400">Attack Vectors: </span>
          <span className="text-red-400 font-semibold">{attacks.length}</span>
          {isRefreshing && <span className="text-yellow-400 ml-1">‚Üª</span>}
        </div>
        <div className={`bg-gray-700 px-3 py-1 rounded transition-all duration-300 ${isRefreshing ? 'bg-gray-600 animate-pulse' : ''}`}>
          <span className="text-gray-400">Global Threats: </span>
          <span className="text-orange-400 font-semibold">{threats.length}</span>
          {isRefreshing && <span className="text-yellow-400 ml-1">‚Üª</span>}
        </div>
        <div className={`bg-gray-700 px-3 py-1 rounded transition-all duration-300 ${isRefreshing ? 'bg-gray-600 animate-pulse' : ''}`}>
          <span className="text-gray-400">Active Connections: </span>
          <span className="text-blue-400 font-semibold">{arcs.length}</span>
          {isRefreshing && <span className="text-yellow-400 ml-1">‚Üª</span>}
        </div>
      </div> */}

      {/* Maps Container */}
      <div className="flex gap-6 h-full">
        {/* 2D Map - 2/3 width */}
        <div className="flex-1" style={{ flexBasis: '66.666%' }}>
          <Map2D attacks={attacks} isRefreshing={isRefreshing} />
        </div>
        
        {/* 3D Globe - 1/3 width */}
        <div className="flex-1" style={{ flexBasis: '33.333%' }}>
          <Globe3DMap threats={threats} arcs={arcs} isRefreshing={isRefreshing} />
        </div>
      </div>
    </div>
  );
}










src\contexts\ThreatDataContext.tsx:

// src/contexts/ThreatDataContext.tsx
'use client';

import React, { createContext, useContext, useState, useEffect, useRef, ReactNode } from 'react';

// Types
interface AttackData {
  id: string;
  sourceIp: string;
  sourceLat: number;
  sourceLng: number;
  sourceCountry: string;
  targetIp: string;
  targetLat: number;
  targetLng: number;
  targetCountry: string;
  attackType: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  timestamp: Date;
}

interface ThreatData {
  lat: number;
  lng: number;
  size: number;
  color: string;
  attackType: string;
  count: number;
  country?: string;
}

interface ArcData {
  startLat: number;
  startLng: number;
  endLat: number;
  endLng: number;
  color: string;
  strokeWidth: number;
}

interface ThreatDataContextType {
  attacks: AttackData[];
  threats: ThreatData[];
  arcs: ArcData[];
  isLoading: boolean;
  lastUpdated: Date | null;
  refreshData: () => Promise<void>;
  isRefreshing: boolean;
}

const ThreatDataContext = createContext<ThreatDataContextType | undefined>(undefined);

// Custom hook to use the context
export const useThreatData = () => {
  const context = useContext(ThreatDataContext);
  if (context === undefined) {
    throw new Error('useThreatData must be used within a ThreatDataProvider');
  }
  return context;
};

// Generate custom attack data
const generateCustomAttackData = (): AttackData[] => {
  const attackTypes = ['DDoS', 'Malware', 'Phishing', 'Brute Force', 'SQL Injection', 'XSS', 'Ransomware', 'Port Scan'];
  const severities: ('low' | 'medium' | 'high' | 'critical')[] = ['low', 'medium', 'high', 'critical'];
  
  const serverLocations = [
    { lat: 37.7749, lng: -122.4194, ip: '192.168.1.100', country: 'USA' },
    { lat: 40.7128, lng: -74.0060, ip: '192.168.1.101', country: 'USA' },
    { lat: 51.5074, lng: -0.1278, ip: '192.168.1.102', country: 'UK' },
    { lat: 35.6762, lng: 139.6503, ip: '192.168.1.103', country: 'Japan' },
    { lat: 1.3521, lng: 103.8198, ip: '192.168.1.104', country: 'Singapore' },
  ];

  const attackSources = [
    { lat: 39.9042, lng: 116.4074, country: 'China', threatLevel: 'high' },
    { lat: 55.7558, lng: 37.6173, country: 'Russia', threatLevel: 'critical' },
    { lat: 28.6139, lng: 77.2090, country: 'India', threatLevel: 'medium' },
    { lat: -23.5505, lng: -46.6333, country: 'Brazil', threatLevel: 'medium' },
    { lat: 52.5200, lng: 13.4050, country: 'Germany', threatLevel: 'low' },
    { lat: 25.2048, lng: 55.2708, country: 'UAE', threatLevel: 'low' },
    { lat: 40.7589, lng: -73.9851, country: 'USA', threatLevel: 'medium' },
    { lat: 51.5074, lng: -0.1278, country: 'UK', threatLevel: 'low' },
  ];

  return Array.from({ length: 100 }, (_, i) => {
    const source = attackSources[Math.floor(Math.random() * attackSources.length)];
    const target = serverLocations[Math.floor(Math.random() * serverLocations.length)];
    
    let severity: 'low' | 'medium' | 'high' | 'critical';
    switch (source.threatLevel) {
      case 'critical':
        severity = Math.random() > 0.3 ? 'critical' : 'high';
        break;
      case 'high':
        severity = Math.random() > 0.4 ? 'high' : 'medium';
        break;
      case 'medium':
        severity = Math.random() > 0.5 ? 'medium' : 'low';
        break;
      default:
        severity = Math.random() > 0.7 ? 'medium' : 'low';
    }

    return {
      id: `custom-attack-${i}-${Date.now()}`,
      sourceIp: `${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`,
      sourceLat: source.lat + (Math.random() - 0.5) * 6,
      sourceLng: source.lng + (Math.random() - 0.5) * 6,
      sourceCountry: source.country,
      targetIp: target.ip,
      targetLat: target.lat,
      targetLng: target.lng,
      targetCountry: target.country,
      attackType: attackTypes[Math.floor(Math.random() * attackTypes.length)],
      severity: severity,
      timestamp: new Date(Date.now() - Math.random() * 86400000),
    };
  });
};

// Fetch OTX threat data
const fetchOTXThreatData = async (): Promise<{ threats: ThreatData[], arcs: ArcData[] }> => {
  try {
    const response = await fetch('/api/otx-proxy', {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    });

    if (response.ok) {
      const data = await response.json();
      
      if (data.success && data.threats && data.arcs) {
        return {
          threats: data.threats,
          arcs: data.arcs
        };
      }
    }
    
    throw new Error('Failed to fetch OTX data');
  } catch (error) {
    console.error('Failed to fetch OTX data via proxy:', error);
    throw error;
  }
};

// Provider component
interface ThreatDataProviderProps {
  children: ReactNode;
  refreshInterval?: number; // in milliseconds, default 30 seconds
}

export const ThreatDataProvider: React.FC<ThreatDataProviderProps> = ({ 
  children, 
  refreshInterval = 30000 
}) => {
  const [attacks, setAttacks] = useState<AttackData[]>([]);
  const [threats, setThreats] = useState<ThreatData[]>([]);
  const [arcs, setArcs] = useState<ArcData[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [lastUpdated, setLastUpdated] = useState<Date | null>(null);
  
  const intervalRef = useRef<NodeJS.Timeout | null>(null);
  const mountedRef = useRef(true);

  // Function to fetch all data
  const fetchAllData = async (isManualRefresh = false) => {
    if (isManualRefresh) {
      setIsRefreshing(true);
    }
    // Don't set isLoading to true for background refreshes - only for initial load
    if (attacks.length === 0 && threats.length === 0) {
      setIsLoading(true);
    }

    try {
      console.log('üîÑ Fetching threat data...');
      
      const [customAttackData, otxThreatResponse] = await Promise.all([
        Promise.resolve(generateCustomAttackData()),
        fetchOTXThreatData()
      ]);

      // Only update state if component is still mounted
      if (mountedRef.current) {
        setAttacks(customAttackData);
        setThreats(otxThreatResponse.threats);
        setArcs(otxThreatResponse.arcs);
        setLastUpdated(new Date());
        
        console.log('‚úÖ Threat data updated:', {
          attacks: customAttackData.length,
          threats: otxThreatResponse.threats.length,
          arcs: otxThreatResponse.arcs.length
        });
      }
    } catch (error) {
      console.error('‚ùå Error fetching threat data:', error);
      
      // Only fallback to empty data on initial load failure
      if (mountedRef.current && attacks.length === 0 && threats.length === 0) {
        const fallbackAttacks = generateCustomAttackData();
        setAttacks(fallbackAttacks);
        setThreats([]);
        setArcs([]);
        setLastUpdated(new Date());
      }
    } finally {
      if (mountedRef.current) {
        setIsLoading(false);
        setIsRefreshing(false);
      }
    }
  };

  // Manual refresh function
  const refreshData = async () => {
    await fetchAllData(true);
  };

  // Initial data load and interval setup
  useEffect(() => {
    mountedRef.current = true;
    
    // Initial load
    fetchAllData();

    // Set up auto-refresh interval
    intervalRef.current = setInterval(() => {
      if (mountedRef.current) {
        fetchAllData();
      }
    }, refreshInterval);

    // Cleanup function
    return () => {
      mountedRef.current = false;
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, [refreshInterval]);

  // Handle visibility change (pause/resume when tab is not visible)
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.hidden) {
        // Tab is hidden, clear interval
        if (intervalRef.current) {
          clearInterval(intervalRef.current);
          intervalRef.current = null;
        }
      } else {
        // Tab is visible, resume interval if not already running
        if (!intervalRef.current && mountedRef.current) {
          intervalRef.current = setInterval(() => {
            if (mountedRef.current) {
              fetchAllData();
            }
          }, refreshInterval);
          
          // Also fetch fresh data when tab becomes visible
          fetchAllData();
        }
      }
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);
    
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, [refreshInterval]);

  const contextValue: ThreatDataContextType = {
    attacks,
    threats,
    arcs,
    isLoading,
    lastUpdated,
    refreshData,
    isRefreshing
  };

  return (
    <ThreatDataContext.Provider value={contextValue}>
      {children}
    </ThreatDataContext.Provider>
  );
};











src\app\(client)\layout.tsx:

import { Sidebar } from '@/components/layout/sidebar';
import { Header } from '@/components/layout/header';
import { Footer } from '@/components/layout/footer';
import { AIChatbot } from '@/components/layout/ai-chatbot';
import AuthGuard from '@/components/auth/AuthGuard';
import { ThreatDataProvider } from '@/contexts/ThreatDataContext';

export default function ClientLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <AuthGuard requiredRole="client">
        <ThreatDataProvider refreshInterval={60000}>
            <div className="min-h-screen bg-gradient-to-br from-gray-50 to-gray-100 dark:from-gray-900 dark:to-gray-950 flex flex-col">
                <Sidebar />
                <div className="lg:pl-72 flex flex-col min-h-screen">
                <Header />
                <main className="py-8 flex-1 animate-fade-in">
                    <div className="px-4 sm:px-6 lg:px-8 max-w-7xl mx-auto">
                    {children}
                    </div>
                </main>
                <Footer />
                </div>
                <AIChatbot />
            </div>
      </ThreatDataProvider>
    </AuthGuard>
  );
}












src\app\api\otx-proxy\route.ts:

// src/app/api/otx-proxy/route.ts

import { NextRequest } from 'next/server';

// Types
interface ThreatData {
  lat: number;
  lng: number;
  size: number;
  color: string;
  attackType: string;
  count: number;
  country?: string;
}

interface ArcData {
  startLat: number;
  startLng: number;
  endLat: number;
  endLng: number;
  color: string;
  strokeWidth: number;
}

// Enhanced IP Geolocation function with multiple fallbacks
const getIpLocation = async (ip: string): Promise<{lat: number, lng: number, country: string} | null> => {
  const services = [
    // Service 1: ip-api.com (free, no key required, 1000 requests/month)
    async () => {
      const response = await fetch(`http://ip-api.com/json/${ip}?fields=status,message,country,lat,lon`);
      if (response.ok) {
        const data = await response.json();
        if (data.status === 'success') {
          return {
            lat: parseFloat(data.lat) || 0,
            lng: parseFloat(data.lon) || 0,
            country: data.country || 'Unknown'
          };

        }
      }
      return null;
    },
    
    // Service 2: ipapi.co (backup)
    async () => {
      const response = await fetch(`https://ipapi.co/${ip}/json/`);
      if (response.ok) {
        const data = await response.json();
        if (data.latitude && data.longitude) {
          return {
            lat: parseFloat(data.latitude) || 0,
            lng: parseFloat(data.longitude) || 0,
            country: data.country_name || 'Unknown'
          };
        }
      }
      return null;
    },
    
    // Service 3: ipwhois.app (free)
    async () => {
      const response = await fetch(`http://ipwhois.app/json/${ip}`);
      if (response.ok) {
        const data = await response.json();
        if (data.latitude && data.longitude) {
          return {
            lat: parseFloat(data.latitude) || 0,
            lng: parseFloat(data.longitude) || 0,
            country: data.country || 'Unknown'
          };
        }
      }
      return null;
    }
  ];

  // Try each service with timeout
  for (const [index, service] of services.entries()) {
    try {
      console.log(`üåê Trying geolocation service ${index + 1} for IP: ${ip}`);
      
      // Add timeout to prevent hanging
      const timeoutPromise = new Promise<null>((_, reject) => 
        setTimeout(() => reject(new Error('Timeout')), 5000)
      );
      
      const result = await Promise.race([service(), timeoutPromise]);
      
      if (result && result.lat !== 0 && result.lng !== 0) {
        console.log(`‚úÖ Geolocation success with service ${index + 1}:`, result);
        return result;
      }
    } catch (error) {
      console.log(`‚ùå Geolocation service ${index + 1} failed for ${ip}:`, error instanceof Error ? error.message : 'Unknown error');
      continue;
    }
  }

  console.log(`‚ùå All geolocation services failed for IP: ${ip}`);
  return null;
};

// Rate limiting helper
const rateLimitDelay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

// Main OTX data fetching function
const fetchOTXThreatData = async (apiKey: string): Promise<{ threats: ThreatData[], arcs: ArcData[] }> => {
  try {
    console.log('üîê Making OTX API request...');
    
    // Fetch subscribed pulses from OTX (increased from 50 to 100)
    let pulsesResponse = await fetch('https://otx.alienvault.com/api/v1/pulses/subscribed?limit=100', {
      method: 'GET',
      headers: {
        'X-OTX-API-KEY': apiKey,
        'Content-Type': 'application/json',
        'User-Agent': 'ThreatMap/1.0'
      }
    });

    console.log('üì° OTX Subscribed Pulses Response status:', pulsesResponse.status);

    // If subscribed pulses fail or return empty, try public pulses
    let pulsesData;
    if (!pulsesResponse.ok) {
      console.log('‚ö†Ô∏è Subscribed pulses failed, trying public pulses...');
      pulsesResponse = await fetch('https://otx.alienvault.com/api/v1/pulses/activity?limit=100', {
        method: 'GET',
        headers: {
          'X-OTX-API-KEY': apiKey,
          'Content-Type': 'application/json',
          'User-Agent': 'ThreatMap/1.0'
        }
      });
      console.log('üì° OTX Public Pulses Response status:', pulsesResponse.status);
    }

    if (!pulsesResponse.ok) {
      const errorText = await pulsesResponse.text();
      console.error('‚ùå OTX API Error Response:', errorText);
      throw new Error(`OTX API request failed: ${pulsesResponse.status} - ${errorText}`);
    }

    pulsesData = await pulsesResponse.json();
    console.log('üì¶ Pulses data structure:', {
      hasResults: !!pulsesData.results,
      resultsType: Array.isArray(pulsesData.results) ? 'array' : typeof pulsesData.results,
      resultsLength: pulsesData.results?.length || 0,
      samplePulse: pulsesData.results?.[0] ? {
        id: pulsesData.results[0].id,
        name: pulsesData.results[0].name,
        tags: pulsesData.results[0].tags,
        indicatorCount: pulsesData.results[0].indicator_count
      } : 'none'
    });

    const threats: ThreatData[] = [];
    const processedIPs = new Set<string>();

    if (pulsesData.results && Array.isArray(pulsesData.results)) {
      console.log(`üîÑ Processing ${pulsesData.results.length} pulses...`);
      
      // Extract IP indicators from pulses (increased from 10 to 30)
      for (const [pulseIndex, pulse] of pulsesData.results.slice(0, 50).entries()) {
        try {
          console.log(`üìã Processing pulse ${pulseIndex + 1}: ${pulse.name}`);
          
          // Get indicators for this pulse
          const indicatorsResponse = await fetch(`https://otx.alienvault.com/api/v1/pulses/${pulse.id}/indicators`, {
            headers: { 
              'X-OTX-API-KEY': apiKey,
              'User-Agent': 'ThreatMap/1.0'
            }
          });

          if (indicatorsResponse.ok) {
            const indicatorsData = await indicatorsResponse.json();
            
            console.log(`üìä Indicators for pulse ${pulse.name}:`, {
              totalResults: indicatorsData.results?.length || 0,
              ipv4Count: indicatorsData.results?.filter((i: any) => i.type === 'IPv4').length || 0
            });
            
            // Process IP indicators
            const ipIndicators = indicatorsData.results?.filter((indicator: any) => 
              indicator.type === 'IPv4' && !processedIPs.has(indicator.indicator)
            ) || [];

            console.log(`üéØ Found ${ipIndicators.length} unique IPv4 indicators`);

            for (const [ipIndex, ipIndicator] of ipIndicators.slice(0, 5).entries()) {
              processedIPs.add(ipIndicator.indicator);
              
              console.log(`üåç Getting geolocation for IP ${ipIndex + 1}: ${ipIndicator.indicator}`);
              
              // Get geolocation for IP
              const location = await getIpLocation(ipIndicator.indicator);
              
              console.log(`üìç Location result:`, location);
              
              if (location && location.lat !== 0 && location.lng !== 0) {
                // Determine threat type and color
                const threatType = pulse.malware_families?.[0]?.name || 
                                 (pulse.tags?.includes('phishing') ? 'Phishing' :
                                  pulse.tags?.includes('malware') ? 'Malware' :
                                  pulse.tags?.includes('botnet') ? 'Botnet' : 'Unknown');

                const otxColors: { [key: string]: string } = {
                  'Malware': '#FF6B6B',
                  'Phishing': '#4ECDC4', 
                  'Botnet': '#45B7D1',
                  'APT': '#FFA07A',
                  'Exploit': '#98D8C8',
                  'Unknown': '#F7DC6F'
                };

                const threat = {
                  lat: location.lat,
                  lng: location.lng,
                  size: Math.random() * 0.8 + 0.4,
                  color: otxColors[threatType] || otxColors['Unknown'],
                  attackType: `${threatType}: ${pulse.name}`,
                  count: pulse.indicator_count || 1,
                  country: location.country
                };

                threats.push(threat);
                console.log(`‚úÖ Added threat:`, threat);
              } else {
                console.log(`‚ùå Skipping IP ${ipIndicator.indicator} - invalid location`);
              }

              // Rate limiting - wait between requests
              await rateLimitDelay(100);
            }
          } else {
            console.error(`‚ùå Failed to get indicators for pulse ${pulse.id}:`, indicatorsResponse.status);
          }
        } catch (error) {
          console.error(`‚ùå Error processing pulse ${pulse.id}:`, error);
        }
      }
    } else {
      console.error('‚ùå No valid results array in pulses data');
    }

    console.log(`üéâ Final threats collected: ${threats.length}`);

    // Generate more arcs connecting threats (increased from 20 to 50)
    const arcs: ArcData[] = [];
    const arcColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#E74C3C', '#3498DB', '#2ECC71', '#F39C12', '#9B59B6'];
    
    // Create more diverse arc patterns
    const maxArcs = Math.min(50, threats.length * 2);
    for (let i = 0; i < maxArcs && i < threats.length - 1; i++) {
      const sourceIndex = Math.floor(Math.random() * threats.length);
      const targetIndex = Math.floor(Math.random() * threats.length);
      
      if (sourceIndex !== targetIndex) {
        const source = threats[sourceIndex];
        const target = threats[targetIndex];
        
        arcs.push({
          startLat: source.lat,
          startLng: source.lng,
          endLat: target.lat,
          endLng: target.lng,
          color: arcColors[Math.floor(Math.random() * arcColors.length)],
          strokeWidth: Math.random() * 3 + 0.5 // Varied thickness
        });
      }
    }

    console.log(`üîó Generated ${arcs.length} arcs`);

    return { threats, arcs };
  } catch (error) {
    console.error('‚ùå Failed to fetch OTX data:', error);
    throw error;
  }
};

// Additional function to fetch from OTX public activity for more data
const fetchOTXPublicData = async (apiKey: string): Promise<{ threats: ThreatData[], arcs: ArcData[] }> => {
  try {
    console.log('üîê Making OTX Public Activity API request...');
    
    const pulsesResponse = await fetch('https://otx.alienvault.com/api/v1/pulses/activity?limit=50', {
      method: 'GET',
      headers: {
        'X-OTX-API-KEY': apiKey,
        'Content-Type': 'application/json',
        'User-Agent': 'ThreatMap/1.0'
      }
    });

    if (!pulsesResponse.ok) {
      throw new Error(`OTX Public API request failed: ${pulsesResponse.status}`);
    }

    const pulsesData = await pulsesResponse.json();
    const threats: ThreatData[] = [];
    const processedIPs = new Set<string>();

    if (pulsesData.results && Array.isArray(pulsesData.results)) {
      console.log(`üîÑ Processing ${pulsesData.results.length} public pulses...`);
      
      for (const [pulseIndex, pulse] of pulsesData.results.slice(0, 15).entries()) {
        try {
          const indicatorsResponse = await fetch(`https://otx.alienvault.com/api/v1/pulses/${pulse.id}/indicators`, {
            headers: { 
              'X-OTX-API-KEY': apiKey,
              'User-Agent': 'ThreatMap/1.0'
            }
          });

          if (indicatorsResponse.ok) {
            const indicatorsData = await indicatorsResponse.json();
            const ipIndicators = indicatorsData.results?.filter((indicator: any) => 
              indicator.type === 'IPv4' && !processedIPs.has(indicator.indicator)
            ) || [];

            for (const [ipIndex, ipIndicator] of ipIndicators.slice(0, 4).entries()) {
              processedIPs.add(ipIndicator.indicator);
              
              const location = await getIpLocation(ipIndicator.indicator);
              
              if (location && location.lat !== 0 && location.lng !== 0) {
                const threatType = pulse.malware_families?.[0]?.name || 
                                 (pulse.tags?.includes('phishing') ? 'Phishing' :
                                  pulse.tags?.includes('malware') ? 'Malware' :
                                  pulse.tags?.includes('botnet') ? 'Botnet' : 'Public Threat');

                const otxColors: { [key: string]: string } = {
                  'Malware': '#FF6B6B',
                  'Phishing': '#4ECDC4', 
                  'Botnet': '#45B7D1',
                  'APT': '#FFA07A',
                  'Exploit': '#98D8C8',
                  'Public Threat': '#E67E22'
                };

                threats.push({
                  lat: location.lat,
                  lng: location.lng,
                  size: Math.random() * 0.8 + 0.4,
                  color: otxColors[threatType] || otxColors['Public Threat'],
                  attackType: `${threatType}: ${pulse.name}`,
                  count: pulse.indicator_count || 1,
                  country: location.country
                });
              }

              await rateLimitDelay(150);
            }
          }
        } catch (error) {
          console.error(`‚ùå Error processing public pulse ${pulse.id}:`, error);
        }
      }
    }

    const arcs: ArcData[] = [];
    const arcColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8'];
    
    for (let i = 0; i < Math.min(25, threats.length - 1); i++) {
      if (i + 1 < threats.length) {
        const source = threats[i];
        const target = threats[i + 1];
        
        arcs.push({
          startLat: source.lat,
          startLng: source.lng,
          endLat: target.lat,
          endLng: target.lng,
          color: arcColors[Math.floor(Math.random() * arcColors.length)],
          strokeWidth: Math.random() * 2 + 1
        });
      }
    }

    console.log(`üéâ Public data collected: ${threats.length} threats, ${arcs.length} arcs`);
    return { threats, arcs };
  } catch (error) {
    console.error('‚ùå Failed to fetch OTX public data:', error);
    return { threats: [], arcs: [] };
  }
};

// Mock data fallback
const generateMockOTXData = (): { threats: ThreatData[], arcs: ArcData[] } => {
  const otxThreatTypes = ['APT Campaign', 'Malware Family', 'Phishing Campaign', 'Botnet C2', 'Exploit Kit'];
  const otxColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8'];
  
  const realThreatLocations = [
    { lat: 39.9042, lng: 116.4074, country: 'China' },
    { lat: 55.7558, lng: 37.6173, country: 'Russia' },
    { lat: 28.6139, lng: 77.2090, country: 'India' },
    { lat: 40.7128, lng: -74.0060, country: 'USA' },
    { lat: 52.5200, lng: 13.4050, country: 'Germany' },
    { lat: 51.5074, lng: -0.1278, country: 'UK' },
    { lat: 35.6762, lng: 139.6503, country: 'Japan' },
    { lat: -23.5505, lng: -46.6333, country: 'Brazil' }
  ];

  const threats = Array.from({ length: 100 }, (_, i) => { // Increased from 50 to 100
    const location = realThreatLocations[i % realThreatLocations.length];
    return {
      lat: location.lat + (Math.random() - 0.5) * 8,
      lng: location.lng + (Math.random() - 0.5) * 8,
      size: Math.random() * 0.8 + 0.4,
      color: otxColors[Math.floor(Math.random() * otxColors.length)],
      attackType: otxThreatTypes[Math.floor(Math.random() * otxThreatTypes.length)],
      count: Math.floor(Math.random() * 1000) + 100,
      country: location.country
    };
  });

  const arcs = Array.from({ length: 75 }, () => { // Increased from 25 to 75
    const source = realThreatLocations[Math.floor(Math.random() * realThreatLocations.length)];
    const target = realThreatLocations[Math.floor(Math.random() * realThreatLocations.length)];
    
    return {
      startLat: source.lat + (Math.random() - 0.5) * 5,
      startLng: source.lng + (Math.random() - 0.5) * 5,
      endLat: target.lat + (Math.random() - 0.5) * 5,
      endLng: target.lng + (Math.random() - 0.5) * 5,
      color: otxColors[Math.floor(Math.random() * otxColors.length)],
      strokeWidth: Math.random() * 2 + 1
    };
  });

  return { threats, arcs };
};

// App Router GET Handler
export async function GET(request: Request) {
  try {
    // Get OTX API key from environment variables
    const OTX_API_KEY = process.env.ALIEN_VAULT_OTX_API_KEY;
    
    console.log('üîç DEBUG - API Key check:', {
      hasApiKey: !!OTX_API_KEY,
      keyLength: OTX_API_KEY?.length || 0,
      firstChars: OTX_API_KEY?.substring(0, 8) || 'none'
    });
    
    if (!OTX_API_KEY || OTX_API_KEY === 'YOUR_OTX_API_KEY_HERE') {
      console.warn('‚ö†Ô∏è OTX API key not configured, using enhanced mock data');
      const mockData = generateMockOTXData();
      return Response.json({
        success: true,
        threats: mockData.threats,
        arcs: mockData.arcs,
        source: 'mock'
      });
    }

    console.log('üöÄ Fetching enhanced OTX data from multiple sources...');
    
    // Fetch from multiple OTX endpoints in parallel for more data
    const [subscribedData, activityData] = await Promise.allSettled([
      fetchOTXThreatData(OTX_API_KEY),
      fetchOTXPublicData(OTX_API_KEY)
    ]);
    
    let allThreats: ThreatData[] = [];
    let allArcs: ArcData[] = [];
    
    // Combine data from both sources
    if (subscribedData.status === 'fulfilled') {
      allThreats.push(...subscribedData.value.threats);
      allArcs.push(...subscribedData.value.arcs);
      console.log(`‚úÖ Added ${subscribedData.value.threats.length} threats from subscribed pulses`);
    }
    
    if (activityData.status === 'fulfilled') {
      allThreats.push(...activityData.value.threats);
      allArcs.push(...activityData.value.arcs);
      console.log(`‚úÖ Added ${activityData.value.threats.length} threats from activity pulses`);
    }
    
    // Remove duplicates based on coordinates
    const uniqueThreats = allThreats.filter((threat, index, self) => 
      index === self.findIndex(t => t.lat === threat.lat && t.lng === threat.lng)
    );
    
    console.log(`üìä Total unique threats: ${uniqueThreats.length}, Total arcs: ${allArcs.length}`);
    
    return Response.json({
      success: true,
      threats: uniqueThreats,
      arcs: allArcs,
      source: 'otx_enhanced'
    });

  } catch (error) {
    console.error('‚ùå OTX Proxy API Error:', error);
    
    // Return enhanced mock data as fallback
    const mockData = generateMockOTXData();
    return Response.json({
      success: true,
      threats: mockData.threats,
      arcs: mockData.arcs,
      source: 'mock_fallback',
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
}










.env.local:


ALIEN_VAULT_OTX_API_KEY=49cc8c3309309921571cc4bed443c16edf15f3a430fee9b25af8297ed561eeb8