'use client';

import React, { useState, useEffect, useRef } from 'react';
import dynamic from 'next/dynamic';
import * as d3 from 'd3';

// Dynamic imports for client-side only components
const Globe3D = dynamic(() => import('react-globe.gl'), { ssr: false });

// Types
interface AttackData {
  id: string;
  sourceIp: string;
  sourceLat: number;
  sourceLng: number;
  sourceCountry: string;
  targetIp: string;
  targetLat: number;
  targetLng: number;
  targetCountry: string;
  attackType: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  timestamp: Date;
}

interface ThreatData {
  lat: number;
  lng: number;
  size: number;
  color: string;
  attackType: string;
  count: number;
  country?: string;
}

interface ArcData {
  startLat: number;
  startLng: number;
  endLat: number;
  endLng: number;
  color: string;
  strokeWidth: number;
}

// IP Geolocation function (using ipapi.co for demo - replace with your preferred service)
const getIpLocation = async (ip: string): Promise<{lat: number, lng: number, country: string} | null> => {
  try {
    // Using a free IP geolocation service - replace with your preferred provider
    const response = await fetch(`https://ipapi.co/${ip}/json/`);
    if (response.ok) {
      const data = await response.json();
      return {
        lat: parseFloat(data.latitude) || 0,
        lng: parseFloat(data.longitude) || 0,
        country: data.country_name || 'Unknown'
      };
    }
  } catch (error) {
    console.error('IP geolocation failed:', error);
  }
  return null;
};

// AlienVault OTX DirectConnect API integration for 3D map
const fetchOTXThreatData = async (): Promise<{ threats: ThreatData[], arcs: ArcData[] }> => {
  try {
    // Note: Replace with your actual OTX API key
    const OTX_API_KEY = 'YOUR_OTX_API_KEY_HERE';
    
    // Check if API key is configured
    if (OTX_API_KEY === 'YOUR_OTX_API_KEY_HERE') {
      console.warn('OTX API key not configured, using mock data');
      return generateMockOTXData();
    }

    // Fetch subscribed pulses from OTX
    const pulsesResponse = await fetch('https://otx.alienvault.com/api/v1/pulses/subscribed?limit=50', {
      method: 'GET',
      headers: {
        'X-OTX-API-KEY': OTX_API_KEY,
        'Content-Type': 'application/json'
      }
    });

    if (pulsesResponse.ok) {
      const pulsesData = await pulsesResponse.json();
      const threats: ThreatData[] = [];
      const processedIPs = new Set<string>();

      if (pulsesData.results && Array.isArray(pulsesData.results)) {
        // Extract IP indicators from pulses
        for (const pulse of pulsesData.results.slice(0, 20)) {
          try {
            // Get indicators for this pulse
            const indicatorsResponse = await fetch(`https://otx.alienvault.com/api/v1/pulses/${pulse.id}/indicators`, {
              headers: { 'X-OTX-API-KEY': OTX_API_KEY }
            });

            if (indicatorsResponse.ok) {
              const indicatorsData = await indicatorsResponse.json();
              
              // Process IP indicators
              const ipIndicators = indicatorsData.results?.filter((indicator: any) => 
                indicator.type === 'IPv4' && !processedIPs.has(indicator.indicator)
              ) || [];

              for (const ipIndicator of ipIndicators.slice(0, 5)) {
                processedIPs.add(ipIndicator.indicator);
                
                // Get geolocation for IP
                const location = await getIpLocation(ipIndicator.indicator);
                
                if (location && location.lat !== 0 && location.lng !== 0) {
                  // Determine threat type and color
                  const threatType = pulse.malware_families?.[0]?.name || 
                                   (pulse.tags?.includes('phishing') ? 'Phishing' :
                                    pulse.tags?.includes('malware') ? 'Malware' :
                                    pulse.tags?.includes('botnet') ? 'Botnet' : 'Unknown');

                  const otxColors: { [key: string]: string } = {
                    'Malware': '#FF6B6B',
                    'Phishing': '#4ECDC4', 
                    'Botnet': '#45B7D1',
                    'APT': '#FFA07A',
                    'Exploit': '#98D8C8',
                    'Unknown': '#F7DC6F'
                  };

                  threats.push({
                    lat: location.lat,
                    lng: location.lng,
                    size: Math.random() * 0.8 + 0.4,
                    color: otxColors[threatType] || otxColors['Unknown'],
                    attackType: `${threatType}: ${pulse.name}`,
                    count: pulse.indicator_count || 1,
                    country: location.country
                  });
                }

                // Rate limiting - wait between requests
                await new Promise(resolve => setTimeout(resolve, 100));
              }
            }
          } catch (error) {
            console.error('Error processing pulse:', error);
          }
        }
      }

      // Generate arcs connecting threats
      const arcs: ArcData[] = [];
      const arcColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8'];
      
      for (let i = 0; i < Math.min(20, threats.length - 1); i++) {
        const source = threats[i];
        const target = threats[i + 1];
        
        arcs.push({
          startLat: source.lat,
          startLng: source.lng,
          endLat: target.lat,
          endLng: target.lng,
          color: arcColors[Math.floor(Math.random() * arcColors.length)],
          strokeWidth: Math.random() * 2 + 1
        });
      }

      return { threats, arcs };
    } else {
      console.error('OTX API request failed:', pulsesResponse.status);
      return generateMockOTXData();
    }
  } catch (error) {
    console.error('Failed to fetch OTX data:', error);
    return generateMockOTXData();
  }
};

// Mock OTX data for fallback
const generateMockOTXData = (): { threats: ThreatData[], arcs: ArcData[] } => {
  const otxThreatTypes = ['APT Campaign', 'Malware Family', 'Phishing Campaign', 'Botnet C2', 'Exploit Kit'];
  const otxColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8'];
  
  // Generate OTX-style threat points with realistic locations
  const realThreatLocations = [
    { lat: 39.9042, lng: 116.4074, country: 'China' },
    { lat: 55.7558, lng: 37.6173, country: 'Russia' },
    { lat: 28.6139, lng: 77.2090, country: 'India' },
    { lat: 40.7128, lng: -74.0060, country: 'USA' },
    { lat: 52.5200, lng: 13.4050, country: 'Germany' },
    { lat: 51.5074, lng: -0.1278, country: 'UK' },
    { lat: 35.6762, lng: 139.6503, country: 'Japan' },
    { lat: -23.5505, lng: -46.6333, country: 'Brazil' }
  ];

  const threats = Array.from({ length: 50 }, (_, i) => {
    const location = realThreatLocations[i % realThreatLocations.length];
    return {
      lat: location.lat + (Math.random() - 0.5) * 8,
      lng: location.lng + (Math.random() - 0.5) * 8,
      size: Math.random() * 0.8 + 0.4,
      color: otxColors[Math.floor(Math.random() * otxColors.length)],
      attackType: otxThreatTypes[Math.floor(Math.random() * otxThreatTypes.length)],
      count: Math.floor(Math.random() * 1000) + 100,
      country: location.country
    };
  });

  // Generate arcs
  const arcs = Array.from({ length: 25 }, () => {
    const source = realThreatLocations[Math.floor(Math.random() * realThreatLocations.length)];
    const target = realThreatLocations[Math.floor(Math.random() * realThreatLocations.length)];
    
    return {
      startLat: source.lat + (Math.random() - 0.5) * 5,
      startLng: source.lng + (Math.random() - 0.5) * 5,
      endLat: target.lat + (Math.random() - 0.5) * 5,
      endLng: target.lng + (Math.random() - 0.5) * 5,
      color: otxColors[Math.floor(Math.random() * otxColors.length)],
      strokeWidth: Math.random() * 2 + 1
    };
  });

  return { threats, arcs };
};

// Custom dummy data for 2D map (your infrastructure attacks)
const generateCustomAttackData = (): AttackData[] => {
  const attackTypes = ['DDoS', 'Malware', 'Phishing', 'Brute Force', 'SQL Injection', 'XSS', 'Ransomware', 'Port Scan'];
  const severities: ('low' | 'medium' | 'high' | 'critical')[] = ['low', 'medium', 'high', 'critical'];
  
  // Your infrastructure servers (customize these coordinates)
  const serverLocations = [
    { lat: 37.7749, lng: -122.4194, ip: '192.168.1.100', country: 'USA' }, // San Francisco
  ];

  // Realistic attack sources with threat intelligence weights
  const attackSources = [
    { lat: 39.9042, lng: 116.4074, country: 'China', threatLevel: 'high' },
    { lat: 55.7558, lng: 37.6173, country: 'Russia', threatLevel: 'critical' },
    { lat: 28.6139, lng: 77.2090, country: 'India', threatLevel: 'medium' },
    { lat: -23.5505, lng: -46.6333, country: 'Brazil', threatLevel: 'medium' },
    { lat: 52.5200, lng: 13.4050, country: 'Germany', threatLevel: 'low' },
    { lat: 25.2048, lng: 55.2708, country: 'UAE', threatLevel: 'low' },
    { lat: 40.7589, lng: -73.9851, country: 'USA', threatLevel: 'medium' }, // Internal threats
    { lat: 51.5074, lng: -0.1278, country: 'UK', threatLevel: 'low' },
  ];

  // Generate realistic custom attacks
  return Array.from({ length: 30 }, (_, i) => {
    const source = attackSources[Math.floor(Math.random() * attackSources.length)];
    const target = serverLocations[Math.floor(Math.random() * serverLocations.length)];
    
    // Severity based on threat level
    let severity: 'low' | 'medium' | 'high' | 'critical';
    switch (source.threatLevel) {
      case 'critical':
        severity = Math.random() > 0.3 ? 'critical' : 'high';
        break;
      case 'high':
        severity = Math.random() > 0.4 ? 'high' : 'medium';
        break;
      case 'medium':
        severity = Math.random() > 0.5 ? 'medium' : 'low';
        break;
      default:
        severity = Math.random() > 0.7 ? 'medium' : 'low';
    }

    return {
      id: `custom-attack-${i}`,
      sourceIp: `${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`,
      sourceLat: source.lat + (Math.random() - 0.5) * 6,
      sourceLng: source.lng + (Math.random() - 0.5) * 6,
      sourceCountry: source.country,
      targetIp: target.ip,
      targetLat: target.lat,
      targetLng: target.lng,
      targetCountry: target.country,
      attackType: attackTypes[Math.floor(Math.random() * attackTypes.length)],
      severity: severity,
      timestamp: new Date(Date.now() - Math.random() * 86400000),
    };
  });
};

// Fallback threat data (keeping for compatibility)
const fetchURLhausThreatData = async (): Promise<{ threats: ThreatData[], arcs: ArcData[] }> => {
  // This is kept for backward compatibility but will use OTX data instead
  return generateMockOTXData();
};

// 2D Map Component with futuristic styling like the provided image
const Map2D: React.FC<{ attacks: AttackData[] }> = ({ attacks }) => {
  const svgRef = useRef<SVGSVGElement>(null);

  useEffect(() => {
    if (!svgRef.current) return;

    const svg = d3.select(svgRef.current);
    svg.selectAll("*").remove();

    const width = 800;
    const height = 500;

    // Set up projection
    const projection = d3.geoNaturalEarth1()
      .scale(160)
      .translate([width / 2, height / 2]);

    const path = d3.geoPath().projection(projection);

    // Create futuristic effects and filters
    const defs = svg.append("defs");
    
    // Glowing filter for futuristic elements
    const glowFilter = defs.append("filter")
      .attr("id", "glow")
      .attr("x", "-50%")
      .attr("y", "-50%")
      .attr("width", "200%")
      .attr("height", "200%");
    
    glowFilter.append("feGaussianBlur")
      .attr("stdDeviation", "4")
      .attr("result", "coloredBlur");
    
    const feMerge = glowFilter.append("feMerge");
    feMerge.append("feMergeNode").attr("in", "coloredBlur");
    feMerge.append("feMergeNode").attr("in", "SourceGraphic");

    // Pulse filter for animations
    const pulseFilter = defs.append("filter")
      .attr("id", "pulse")
      .attr("x", "-50%")
      .attr("y", "-50%")
      .attr("width", "200%")
      .attr("height", "200%");
    
    pulseFilter.append("feGaussianBlur")
      .attr("stdDeviation", "2")
      .attr("result", "coloredBlur");
    
    const pulseMerge = pulseFilter.append("feMerge");
    pulseMerge.append("feMergeNode").attr("in", "coloredBlur");
    pulseMerge.append("feMergeNode").attr("in", "SourceGraphic");

    // Create world map like the provided image
    d3.json('https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson')
      .then((world: any) => {
        // Draw dark background
        svg.append("rect")
          .attr("width", width)
          .attr("height", height)
          .attr("fill", "#000000ff");

        // Draw countries with the exact styling from the image - dark gray with borders
        svg.append("g")
          .selectAll("path")
          .data(world.features)
          .enter()
          .append("path")
          .attr("d", path)
          .attr("fill", "#d2d2d2ff")
          .attr("stroke", "#a7a7a7ff")
          .attr("stroke-width", 0.5);

        // Define server locations with icons
        const serverLocations = [
          { lat: 37.7749, lng: -122.4194, name: '192.168.1.100', ip: '192.168.1.100' },
        ];

        // Create attack visualization group
        const attackGroup = svg.append("g").attr("class", "attacks");

        // Add server icons (shields)
        serverLocations.forEach((server, index) => {
          const coords = projection([server.lng, server.lat]);
          if (!coords) return;

          // Create server icon group
          const serverGroup = attackGroup.append("g")
            .attr("transform", `translate(${coords[0]}, ${coords[1]})`);

          // Glowing background circle
          serverGroup.append("circle")
            .attr("r", 12)
            .attr("fill", "#00ff88")
            .attr("opacity", 0.2)
            .style("filter", "url(#glow)");

          // Server shield icon
          serverGroup.append("rect")
            .attr("x", -8)
            .attr("y", -8)
            .attr("width", 20)
            .attr("height", 20)
            .attr("fill", "#00ff88")
            .attr("opacity", 0.9)
            .attr("rx", 2)
            .style("filter", "url(#glow)");

          // Add shield symbol
          serverGroup.append("text")
            .attr("text-anchor", "middle")
            .attr("dy", "0.35em")
            .attr("font-family", "monospace")
            .attr("font-size", "10px")
            .attr("font-weight", "bold")
            .attr("fill", "#000")
            .text("ðŸ›¡");

          // Server label
          serverGroup.append("text")
            .attr("text-anchor", "middle")
            .attr("dy", "35")
            .attr("font-family", "monospace")
            .attr("font-size", "12px")
            .attr("font-weight", "bold")
            .attr("fill", "#00bf66ff")
            .text(server.name);

          // Pulsing animation for server
          serverGroup.select("rect")
            .append("animate")
            .attr("attributeName", "opacity")
            .attr("values", "0.9;0.6;0.9")
            .attr("dur", "3s")
            .attr("repeatCount", "indefinite");
        });

        // Draw attack vectors
        attacks.forEach((attack, index) => {
          const source = projection([attack.sourceLng, attack.sourceLat]);
          const target = projection([attack.targetLng, attack.targetLat]);
          
          if (!source || !target) return;

          // Add red attack source dot
          const sourceGroup = attackGroup.append("g")
            .attr("transform", `translate(${source[0]}, ${source[1]})`);

          // Pulsing red dot for attack source
          const attackDot = sourceGroup.append("circle")
            .attr("r", 3)
            .attr("fill", "#ff4444")
            .attr("opacity", 0)
            .style("filter", "url(#pulse)");

          // Animate dot appearance
          attackDot
            .transition()
            .delay(index * 100)
            .duration(500)
            .attr("opacity", 1);

          // Continuous pulsing
          attackDot.append("animate")
            .attr("attributeName", "r")
            .attr("values", "3;6;3")
            .attr("dur", "2s")
            .attr("repeatCount", "indefinite");

          // Add glowing outer ring
          sourceGroup.append("circle")
            .attr("r", 8)
            .attr("fill", "none")
            .attr("stroke", "#ff4444")
            .attr("stroke-width", 1)
            .attr("opacity", 0.5)
            .style("filter", "url(#glow)")
            .append("animate")
            .attr("attributeName", "r")
            .attr("values", "8;12;8")
            .attr("dur", "2s")
            .attr("repeatCount", "indefinite");

          // Create full attack line from source to target
          const attackLine = attackGroup.append("line")
            .attr("x1", source[0])
            .attr("y1", source[1])
            .attr("x2", target[0])
            .attr("y2", target[1])
            .attr("stroke", "#00d7d7ff")
            .attr("stroke-width", 2)
            .attr("opacity", 0)
            .attr("stroke-dasharray", "5,5")
            .attr("marker-end", "url(#arrowhead)")
            .style("filter", "url(#glow)");

          // Animate line appearance
          attackLine
            .transition()
            .delay(index * 100 + 300)
            .duration(800)
            .attr("opacity", 0.7);

          // Add moving energy pulse along the full line
          const movingPulse = attackGroup.append("circle")
            .attr("r", 3)
            .attr("fill", "#ff4444")
            .attr("opacity", 0)
            .style("filter", "url(#glow)");

          // Calculate line length for animation
          const lineLength = Math.sqrt(
            Math.pow(target[0] - source[0], 2) + Math.pow(target[1] - source[1], 2)
          );

          // Animate pulse along the full line from source to target
          const animatePulse = () => {
            movingPulse
              .attr("cx", source[0])
              .attr("cy", source[1])
              .attr("opacity", 1)
              .transition()
              .duration(2000 + (lineLength * 2)) // Duration based on distance
              .ease(d3.easeLinear)
              .attr("cx", target[0])
              .attr("cy", target[1])
              .attr("opacity", 0.3)
              .on("end", () => {
                // Pulse effect when reaching server
                const serverCoords = projection([attack.targetLng, attack.targetLat]);
                if (serverCoords) {
                  attackGroup.append("circle")
                    .attr("cx", serverCoords[0])
                    .attr("cy", serverCoords[1])
                    .attr("r", 5)
                    .attr("fill", "#00ffffff")
                    .attr("opacity", 0.8)
                    .style("filter", "url(#glow)")
                    .transition()
                    .duration(500)
                    .attr("r", 15)
                    .attr("opacity", 0)
                    .remove();
                }
                setTimeout(animatePulse, Math.random() * 3000 + 2000);
              });
          };

          setTimeout(animatePulse, index * 300 + 1500);
        });

        // Enhanced futuristic arrow marker
        defs.append("marker")
          .attr("id", "arrowhead")
          .attr("viewBox", "0 -5 10 10")
          .attr("refX", 8)
          .attr("refY", 0)
          .attr("markerWidth", 8)
          .attr("markerHeight", 8)
          .attr("orient", "auto")
          .append("path")
          .attr("d", "M0,-5L10,0L0,5")
          .attr("fill", "#00ffff")
          .style("filter", "url(#glow)");
      });
  }, [attacks]);

  return (
    <div className="flex flex-col h-full">
      <div className="mb-4">
        <h3 className="text-lg font-semibold text-white mb-2">Live Attack Vectors</h3>
      </div>
      <svg 
        ref={svgRef} 
        width="100%" 
        height="500" 
        className="bg-black rounded-lg border border-gray-600" 
        viewBox="0 0 800 500" 
      />
    </div>
  );
};

// Clean professional 3D Globe Component
const Globe3DMap: React.FC<{ threats: ThreatData[], arcs: ArcData[] }> = ({ threats, arcs }) => {
  const globeRef = useRef<any>();
  const [autoRotate, setAutoRotate] = useState(true);
  const [cameraDistance, setCameraDistance] = useState(300);
  const lastInteractionTime = useRef(Date.now());
  const animationFrameRef = useRef<number>();

  // Dynamic point sizing based on camera distance
  const getDynamicPointSize = (baseSize: number) => {
    const scaleFactor = Math.max(0.4, Math.min(1.5, cameraDistance / 350));
    return baseSize * scaleFactor;
  };

  useEffect(() => {
    if (globeRef.current) {
      const globe = globeRef.current;
      
      // Professional globe settings
      globe.controls().autoRotate = autoRotate;
      globe.controls().autoRotateSpeed = 0.4;
      globe.controls().enableDamping = true;
      globe.controls().dampingFactor = 0.05;
      globe.controls().minDistance = 150;
      globe.controls().maxDistance = 600;
      globe.controls().enablePan = false;
      
      // High quality rendering
      globe.renderer().setPixelRatio(Math.min(window.devicePixelRatio, 2));
      globe.renderer().antialias = true;
      globe.renderer().shadowMap.enabled = false;
      
      // Monitor camera distance for dynamic sizing
      const updateCameraDistance = () => {
        if (globe.camera()) {
          const distance = globe.camera().position.distanceTo(globe.scene().position);
          setCameraDistance(distance);
        }
        animationFrameRef.current = requestAnimationFrame(updateCameraDistance);
      };
      updateCameraDistance();

      // Handle user interaction
      const handleInteractionStart = () => {
        lastInteractionTime.current = Date.now();
        if (autoRotate) {
          setAutoRotate(false);
        }
      };

      const handleInteractionEnd = () => {
        lastInteractionTime.current = Date.now();
      };

      // Listen for interaction events
      const controls = globe.controls();
      controls.addEventListener('start', handleInteractionStart);
      controls.addEventListener('end', handleInteractionEnd);

      // Resume auto-rotation after 12 seconds
      const checkInactivity = setInterval(() => {
        if (Date.now() - lastInteractionTime.current > 12000 && !autoRotate) {
          setAutoRotate(true);
        }
      }, 1000);

      return () => {
        clearInterval(checkInactivity);
        if (animationFrameRef.current) {
          cancelAnimationFrame(animationFrameRef.current);
        }
        if (controls) {
          controls.removeEventListener('start', handleInteractionStart);
          controls.removeEventListener('end', handleInteractionEnd);
        }
      };
    }
  }, [autoRotate]);

  useEffect(() => {
    if (globeRef.current) {
      globeRef.current.controls().autoRotate = autoRotate;
    }
  }, [autoRotate]);

  return (
    <div className="flex flex-col h-full">
      <div className="mb-4">
        <h3 className="text-lg font-semibold text-white mb-2">Global Threat Intelligence</h3>
      </div>
      
      <div className="flex-1 bg-black rounded-lg overflow-hidden border border-gray-700 relative">
        <Globe3D
          ref={globeRef}
          globeImageUrl="//unpkg.com/three-globe/example/img/earth-blue-marble.jpg"
          bumpImageUrl="//unpkg.com/three-globe/example/img/earth-topology.png"
          backgroundImageUrl="//unpkg.com/three-globe/example/img/night-sky.png"
          showAtmosphere={true}
          atmosphereColor="#4a90e2"
          atmosphereAltitude={0.08}
          
          // Clean threat points
          pointsData={threats}
          pointAltitude={0.005}
          pointColor="color"
          pointRadius={(d: any) => getDynamicPointSize(d.size * 0.6)}
          pointResolution={8}
          pointsMerge={false}
          
          // Realistic arcs
          arcsData={arcs}
          arcColor={(d: any) => d.color}
          arcStroke={(d: any) => Math.max(0.3, d.strokeWidth * 0.4)}
          arcDashLength={0.4}
          arcDashGap={0.2}
          arcDashAnimateTime={6000}
          arcAltitude={0.15}
          arcAltitudeAutoScale={0.5}
          
          // Clean tooltips
          pointLabel={(d: any) => `
            <div class="bg-black/90 p-2 rounded text-white text-xs border border-gray-600">
              <div class="font-semibold">${d.attackType}</div>
              <div class="text-gray-300">Threats: ${d.count}</div>
              ${d.country ? `<div class="text-gray-400">${d.country}</div>` : ''}
            </div>
          `}
          
          width={400}
          height={500}
          enablePointerInteraction={true}
          animateIn={false}
        />
      </div>
    </div>
  );
};

// Main Component
export function AttackMap() {
  const [attacks, setAttacks] = useState<AttackData[]>([]);
  const [threats, setThreats] = useState<ThreatData[]>([]);
  const [arcs, setArcs] = useState<ArcData[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  // Load initial data
  useEffect(() => {
    const loadData = async () => {
      setIsLoading(true);
      try {
        const [customAttackData, otxThreatResponse] = await Promise.all([
          Promise.resolve(generateCustomAttackData()), // Custom dummy data for 2D map
          fetchOTXThreatData()                        // OTX live data for 3D map
        ]);
        setAttacks(customAttackData);
        setThreats(otxThreatResponse.threats);
        setArcs(otxThreatResponse.arcs);
      } catch (error) {
        console.error('Error loading data:', error);
        // Fallback to mock data
        const mockOTXResponse = generateMockOTXData();
        setAttacks(generateCustomAttackData());
        setThreats(mockOTXResponse.threats);
        setArcs(mockOTXResponse.arcs);
      } finally {
        setIsLoading(false);
      }
    };

    loadData();
  }, []);

  // Auto-refresh data every 30 seconds
  useEffect(() => {
    const interval = setInterval(async () => {
      try {
        const [newCustomAttacks, newOTXResponse] = await Promise.all([
          Promise.resolve(generateCustomAttackData()), // Refresh custom 2D data
          fetchOTXThreatData()                        // Refresh OTX 3D data
        ]);
        setAttacks(newCustomAttacks);
        setThreats(newOTXResponse.threats);
        setArcs(newOTXResponse.arcs);
      } catch (error) {
        console.error('Error refreshing data:', error);
      }
    }, 30000);

    return () => clearInterval(interval);
  }, []);

  if (isLoading) {
    return (
      <div className="w-full h-[600px] bg-gray-800 rounded-lg p-6 border border-gray-700 flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto"></div>
          <p className="text-gray-300 mt-4">Loading threat intelligence...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="w-full h-[600px] bg-gray-800 rounded-lg p-6 border border-gray-700">
      <div className="flex gap-6 h-full">
        {/* 2D Map - 2/3 width */}
        <div className="flex-1" style={{ flexBasis: '66.666%' }}>
          <Map2D attacks={attacks} />
        </div>
        
        {/* 3D Globe - 1/3 width */}
        <div className="flex-1" style={{ flexBasis: '33.333%' }}>
          <Globe3DMap threats={threats} arcs={arcs} />
        </div>
      </div>
    </div>
  );
}